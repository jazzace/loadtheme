---
layout: post
title: ðŸ“¦ Feeding AutoDMG and DeployStudio with AutoPkg
---
<a href="https://github.com/autopkg/autopkg" target="_blank">AutoPkg</a> has quickly become the Mac Admin's favourite tool for fetching third party software updates and feeding it in to their software management system. <a href="https://github.com/munki/munki" target="_blank">Munki</a> support for this tool came early. Then, Allister Banks <a href="https://gist.github.com/arubdesu/8190980">added support for those who use Casper,</a> which has since been built upon by Shea Craig. I've also noticed efforts to make AutoPkg work with SCCM by <a>Chris Gerke.</a> But for those with smaller deploymentsâ€”or even those who are just converting away from Golden Machine image bakingâ€”it would be nice to use AutoPkg to automate much of the manual work that is still necessary. Whether updating an image created modularly (e.g., with <a href="https://github.com/MagerValp/AutoDMG" target="_blank">AutoDMG</a>) or updating the packages that we install as a part of our <a href="http://deploystudio.com" target="_blank">DeployStudio</a> workflow (or both), AutoPkg has the ability to do just that. Here's a quick guide.</p>
<h2>AutoPkg Itself</h2>
<p>The rest of this article assumes you have a basic understanding of AutoPkg and how its recipes work. If you need an introduction (or a refresher), there have been excellent presentations at two recent Mac Admin conferences by the primary project contributors Greg Neagle and Tim Sutton (<a href="https://macadmins.psu.edu/conference/resources/" target="_blank">MacAdmins Conference at PSU link</a>, <a href="http://docs.macsysadmin.se/2014/2014doc.html">MacSysAdmin link</a>)â€”I recommend watching both, but note that there is lots of Casper-specific stuff in the MacSysAdmin session. You can also take advantage of the new GUI tool <a href="https://github.com/lindegroup/autopkgr" target="_blank">AutoPkgr</a> from the Linde Group to get set up quickly, even if you do not end up using it to manage your AutoPkg setup.</p>
<h2>The Trick That Makes This Work</h2>
<p>Both DeployStudio workflows and AutoDMG templates store the path to installation payload items but do not make other checks like file size or checksums. As long as the filename and location within the file system remains the same, you can have AutoPkg update the payload without having to alter your workflow or template.</p>
<h3>AutoDMG</h3>
<p>With AutoDMG, it can be very simple. If an AutoPkg recipe of any kind generates something that AutoDMG can use (i.e. dmg with pkg installer, dmg with self-contained app, pkg installer, self-contained app), you can have your AutoDMG template point to the place in the AutoPkg cache where the recipe stores that item. The only place where you might get tripped up is if the item in question has a filename that varies with the version number. Check to see if a recipe override can allow you to use a more generic name or if processing it one more step than otherwise necessary (e.g., from something contained in a dmg to a standalone pkg installer) provides the same ability. If that still doesn't work, you can use one of the DeployStudio recipes (more on this in a moment) to generate a generically-named package installer.</p>
<p>For example, here's the Additional Packages portion of an AutoDMG template that uses installers both from a static repository and the AutoPkg cache:</p>
<pre>
&lt;key&gt;AdditionalPackages&lt;/key&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;array&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;/path/to/Installers/clearReg.pkg&lt;/string&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;/path/to/Installers/create_tech.pkg&lt;/string&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;/path/to/AutoPkg/Cache/<br />com.github.jazzace.pkg.EpsonPrinterDrivers/EpsonPrinterDrivers.pkg&lt;/string&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string&gt;/path/to/AutoPkg/Cache/<br />com.github.hansen-m.download.Fetch/downloads/Fetch.dmg&lt;/string&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&lt;/array&gt;
</pre>
<p class="nb">Note: Paths should all be on one line; they are broken up here due to space considerations.</p>
<p>The first two packages in this example are manually created; they skip registration on first boot and add an admin account (via <a href="http://magervalp.github.io/CreateUserPkg/" target="_blank">CreateUserPkg</a>). They will only be updated manually, so they can be stored in any locally-accessible location I choose (I have an Installers folder for this). The next package is generated by my recipe to extract the EpsonPrinterDriver installer from the dmg (downloaded via a <a href="https://github.com/autopkg/n8felton-recipes" target="_blank">parent recipe from Nate Felton</a>) and give it a static name. (The dmg that Apple provides has the version number appended, hence the need for an extra step in order to provide a static path for the AutoDMG template.) The final one is an example of a common drag-and-drop app where the name of the dmg does not vary from version to version.</p>
<p>So, in summary, I determine which recipes I need to use in order to get a static path, I run those recipes, I add that software to my AutoDMG template from the AutoPkg cache, and then I ensure that AutoPkg has run (or is manually run) shortly before I build a new image.</p>
<h3>DeployStudio</h3>
<p>DeployStudio requires a little more discipline. The payload from AutoPkg must be placed in a specific folder in the DeployStudio repository. This has led me to create recipes with a new extension, .ds, whose sole purpose is to copy a package generated (or retrieved) by a parent recipe into the Packages folder of my DeployStudio recipe. I've included a template in my <a href="https://github.com/autopkg/jazzace-recipes" target="_blank">AutoPkg recipes repo</a> that will let you create the recipes that apply to your situation. In most cases, the parent recipe will be a .pkg.recipe (which you may have to create if only a .download.recipe exists). Just as with AutoDMG, once you have the recipes you need, run them once to populate your DeployStudio repository and then edit your workflows and/or package groups to use those names.</p>
<p>While the template is fairly well documented, let me highlight a few important details. The DS_NAME input variable is what your package will be called, regardless of version (this is how I assure that the package will end up with a predictable name). I have tried to minimize unnecessary copying by using the conditional processor StopProcessingIf. The only trick with StopProcessingIf in this template is that you need to determine which flag tells you whether or not a new version was found in the parent recipe. In general, if the package was extracted, the flag to check will be <cite>download_changed</cite>; if the package was created (e.g., from an app bundle), the flag will be <cite>new_package_request</cite>. When the package is updated, the items get copied to /Volumes/DSServer/Users/Shared/Deploy/Packages, but since your personal repository is probably not located there, you'll want to set up a recipe override.</p>
<p>As a side note, DeployStudio can also copy files in a workflow, so you could use similar techniques to create your own family of recipes (say, .dsfiles.recipe). I'm not sure anyone will, but it is a testament to the flexibility of the tool that this is completely possible with limited technical skill.</p>
<h3>Update Completed</h3>
<p>So no matter which tools you are using â€” Munki, Casper, AutoDMG, DeployStudio â€” there's a way to leverage AutoPkg to keep your software updated without all the manual work to which you have become accustomed.</p>
<hr/>
<p><cite>Updated 2014-12-01 (small correction, re: AutoPkg presentations). Originally posted on the University of Calgary Integrated Arts Media Labs web site.</p>