---
layout: post
title: üì¶ Feeding Outset with Packages using AutoPkg
---
<p><cite>Significant editorial changes made 2025-02-04 to bring this article up-to-date (see note at end).</cite></p>
<p><a href="https://github.com/macadmins/outset" target="_blank">Outset</a> is a great piece of enabling software originally written by Joe Chilcote in Python and implemented in Swift by Bart Reardon. It gets rid of the drudgery of writing launch daemons for things (scripts, packages<a href="#foot1" id="ref1"><sup>[1]</sup></a>) that you want to run after booting, logging in to an account, or even on demand. My primary use for Outset is to establish certain baseline settings for each student user in our computer labs. I place scripts in the <code>login-once</code> folder that either change settings directly (e.g., <code>defaults write</code>) or trigger other tools (e.g., <a href="https://github.com/kcrawford/dockutil" target="_blank">dockutil</a>, <a href="https://github.com/scriptingosx/desktoppr" target="_blank">desktoppr</a>). Unlike loginhooks (long-deprecated) and modifying the system template (a hack), this is a flexible, supported way to do that initial setup.</p>
<p>The question then becomes: how do you get those scripts (or packages) onto the system? The MDM solution we use at our University, Jamf Pro, is not good at dropping arbitrary files into specific locations on the system ‚Äî you need to create a package installer to do this.<a href="#foot2" id="ref2"><sup>[2]</sup></a> Jamf offers a tool to build such packages ‚Äî Composer ‚Äî but that is a manual process. I want to <em>automate</em> the packaging of those scripts for Outset. What are my choices?</p>
<h3>Stand Alone Tools</h3>
<p>I could use a tool like <a href="https://github.com/munki/munki-pkg" target="_blank">munkipkg</a> or <a href="https://github.com/unixorn/luggage" target="_blank">The Luggage</a> to set up a map of what goes where (as per the particular methods of the app) and build a package using a simple command line command any time the script/payload changes. If you are already using either of these tools, you are well-equipped to do this already and the rest of this post will probably be just a curiosity. You could also use Apple‚Äôs <code>pkgbuild</code> tool directly, but the reason the previous tools exist is to make the process simpler than that. <em>Maybe</em> if you‚Äôre <a href="https://books.apple.com/book/packaging-for-apple-administrators/id1173928620" target="_blank">Armin Briegel</a> or you are more DevOps than Mac Admin you do it that way, but that‚Äôs not me.</p>
<h3>Putting the Pkg in AutoPkg</h3>
<p>Users of AutoPkg will realize that it is good at packaging, but perhaps you will not have used it to build a package from something you created (rather than something you downloaded). I can build an AutoPkg recipe that takes a file (in this case, containing a script) and builds a package that installs it in the Outset folder I specify (usually <code>login-once</code>), making sure the file has the executable bit set. My recipe <a href="https://github.com/autopkg/jazzace-recipes/blob/master/JazzAce/OutsetPayloadPkgReqd.pkg.recipe" target="_blank">OutsetPayloadPkgReqd.pkg.recipe</a> is one way to do this. Let‚Äôs examine this from the top.</p>
<h3>Input Variables</h3>
<p>There are two input variables: <code>ACTION_TYPE</code> specifies which Outset folder will receive the script payload and <code>REVERSE_DOMAIN</code> provides the first part of the package identifier (usually customized to your institution or business). I recommend making one override per Outset folder you wish to receive such scripts, renaming the override as you create it:</p>
<pre>autopkg make-override OutsetPayloadPkgReqd.pkg -n Outset-login-once.pkg</pre>
<p>One of the odd things you‚Äôll notice about this recipe is that there is no <code>NAME</code> Input variable, as would be conventional. That is because I want to use it like a utility: every time I run the login-once override, it could be a different script I am packaging. That also explains the first processor, <code>PackageRequired</code>. Every time you run the recipe override, you will specify the location of the script file using the usual syntax:</p>
<pre>autopkg run Outset-login-once.pkg --pkg /path/to/script.sh</pre>
<p>Rather than type the path to the script file, I usually drag and drop it on the Terminal window once the rest of the command has been typed to add the path to the command.<a href="#foot3" id="ref3"><sup>[3]</sup></a>
<h3>Naming the Package</h3>
<p>Since the recipe does not require you to provide a name as an Input variable, I use the next few processors to automatically extract a suitable name from the filename. When you supply the payload using the <code>--pkg</code> (or <code>-p</code>) option, the path to the package is stored in the variable <code>PKG</code>. I use <a href="https://github.com/autopkg/jazzace-recipes/blob/master/JazzAce/TextSearcher.py" target="_blank">my custom processor <code>TextSearcher</code></a> (derived from the core URLTextSearcher procesor code) to first extract everything after the last slash (the script filename), then store that output in the variable <code>name_with_ext</code>, then try to strip the extension (which gets stored in <code>mane_no_ext</code>). I want to use the script name without extension as the tail of the package identifier, but it fails if there are any spaces or underscores, so I use <a href="https://github.com/autopkg/homebysix-recipes/tree/master/FindAndReplace" target="_blank">Elliot Jordan‚Äôs <code>FindAndReplace</code> custom processor</a> to eliminate those.</p>
<p>That leaves us with the three variables we will need when creating the package. As an example, if I ran this recipe with the payload being a file named <code>Garbage_Collection 2023.sh</code>:</p>
<ul><li>name_with_ext = Garbage_Collection 2023.sh</li>
<li>name_no_ext = Garbage_Collection 2023</li>
<li>output_string = GarbageCollection2023</li>
</ul>
<h3>Building the Package Payload Structure</h3>
<p>When you build a package in AutoPkg, you need to create the directory structure where you want the file(s) to go. <code>PkgRootCreator</code> creates directories for this purpose. I need to create the path to <code>/usr/local/outset/login-once</code> (or whichever Outset folder I specified in <code>ACTION_TYPE</code>), so I create the hierarchy using the <code>pkgdirs</code> argument. I create these folders inside the recipe‚Äôs cache in a folder called <code>payload</code> (which is also created by this processor).<a href="#foot4" id="ref4"><sup>[4]</sup></a> I came across one small problem when writing this recipe: the <code>pkgdirs</code> argument does not support variable substitution in the pathnames it creates. However, the <code>FileMover</code> processor gives me a nifty workaround: I name the target folder <code>tmp</code> when I create it but rename it to the value of <code>ACTION_TYPE</code> (usually <code>login-once</code>) using <code>FileMover</code>. Once that is done, I can copy the file that is specified at the command line into that folder.</p>
<h3>Versioning</h3>
<p>The last little detail is that anything built by pkgbuild (which the <code>PkgCreator</code> processor leverages) needs to be assigned a version number. I could have let the user specify that by an Input variable, or I could have created a dependency that required any script deployed by this script to have a version number embedded within the script in a particular format that AutoPkg could parse. Instead, I wrote a processor that generates a version number based on the number of seconds that have passed since a particular fixed time.<a href="#foot5" id="ref5"><sup>[5]</sup></a> Thus, whenever you run the recipe, the version number is always newer than the last run. <code>VersionGenerator</code> places that number (as a string) in the <code>version</code> variable as expected.</p>
<h3>Make it so</h3>
<p>The <code>PkgCreator</code> processor is what builds the package. It accepts a ‚Äúpackage request dictionary,‚Äù whose key entries are <a href="https://github.com/autopkg/autopkg/blob/62992bb0aa65a87ab0306311eae28c55992eb9a9/Code/autopkgserver/autopkgserver#L36-L71" target="_blank">documented in the <code>autopkgserver</code> code.</a> The easiest way to understand how the <code>PkgCreator</code> arguments need to be configured is to look at another recipe that uses it and copy liberally (that is certainly what I do every time I use this processor). Once you examine prior art, it becomes a lot easier to understand. I also find that I sometimes need to change ownership on a file to match what it should be for its location on the file system; this is also done by this processor. My final package has the same name as the shell script name with the (multi-digit) version number appended as per normal convention. I then cleanup the payload directory because I am using this as a utility and I want that directory structure to be empty on every run.</p>
<h3>Frequently Updated Script</h3>
<p>I wrote this recipe to be as flexible and agile as possible, but perhaps your application of it would be for a particular script that you update more regularly ‚Äî you‚Äôd rather not have to drag and drop the file onto Terminal every time. This is completely possible and you don‚Äôt even have to rewrite my recipe. It turns out that if you add the variable <code>PKG</code> to the Input variables in your override and set the value there, <code>PackageRequired</code> will treat it as if it was passed with the <code>--pkg</code> argument. So whether you adopt my more general approach (one override to generate packages for all my login-once scripts) or create a specific override for a particular script with that additional <code>PKG</code> variable, that‚Äôs up to you. (I actually do both.)</p>
<h3>But Wait! There‚Äôs More!</h3>
<p>So now I‚Äôve explained what went into my recipe that takes any script you want to be executed by Outset and turns it into a versioned installer package to be pushed out by your management system. If you want to stop at the package automation and do the rest manually, that‚Äôs great ‚Äî you already have profit! But I want to automate as much as possible. There are two more pieces to my automation puzzle: replacing a script that is already on the system and having Outset run it (which would normally not happen if the previous version had run), and uploading the package to Jamf Pro. But that will have to wait until <a href="/2023/01/03/feeding-outset-2.html" target="_blank">a future post</a>. Have a Happy New Year!</p>
<p><cite>Updated 2025-02-04 to reflect two things: 1. <a href="https://github.com/chilcote/outset" target="_blank">Joe Chilcote‚Äôs Outset</a> has been archived and been replaced by Bart Reardon‚Äôs Swift implementation; and 2. <a href="https://github.com/autopkg/robperc-recipes/blob/master/Processors/StringSplitter.py" target="_blank">Rob Percival‚Äôs StringSplitter processor</a> has been replaced by my TextSearcher processor in the recipe cited due to impending deprecation.<br/>Previously updated 2023-01-01 with minor editoral changes and 2023-01-03 with a link to the subsequent related post (Part 2, if you will).</cite></p>
<hr/>
<p id="foot1">[1] In the wiki for the Python implementation of Outset, you will still see references to configuration profiles as a possible item for its deployment folders. This was true through macOS 10.15 Catalina. As of macOS 11 Big Sur, Apple no longer allows using the <code>profiles</code> command to install configuration profiles, so Outset does not deliver this payload on modern versions of macOS. References to configuration profiles have been removed from the Swift implementation wiki. <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] Jamf Pro does support using a disk image instead of a package, but not in the way you would normally think (especially if you are used to using Munki). You can build such a disk image using Composer, but as you are about to read, my goal is to automate packaging rather than using a manual process. <a href="#ref2">[Return to main text]</a></p>
<p id="foot3">[3] For the login-once override, this is actually a small fib. I use that override often enough that I have created a shell alias called <code>outsetl1</code> for the first part of that command. So what I <em>actually</em> do is type outsetl1, then a space, then drop the script file onto the terminal, then hit Return. If aliases are new to you, I covered them in my <a href="https://github.com/jazzace/autopkg-level-up" target="_blank">AutoPkg Level Up talk at the 2018 Mac Admins Conference.</a> The only major update is that I place the aliases in <code>~/.zshrc</code> because my shell is now zsh. <a href="#ref3">[Return to main text]</a></p>
<p id="foot4">[4] By convention, you would place the folders for your package in a folder named using the value of the Input variable <code>NAME</code>, but this recipe doesn‚Äôt have that variable. An arbitrary variable name works just as well. <a href="#ref4">[Return to main text]</a></p>
<p id="foot5">[5] Currently, that time is 2021-05-21 23:00 UTC, but I have considered adding an ‚Äúepoch‚Äù argument that would let you set your own starting time ‚Äî pull request welcomed. <a href="#ref5">[Return to main text]</a></p>