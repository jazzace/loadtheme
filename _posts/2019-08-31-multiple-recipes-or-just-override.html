---
layout: post
title: ðŸ“¦ Multiple AutoPkg Recipes or Just Override?
---
<p>Iâ€™ve spent a lot of time digging in to the three primary sets of AutoPkg recipes that people commonly use to download Microsoft Office products. The more I dig, the more interesting learning and discussion points I find. Some of these are due to the craft of the authors. Some are due to differences in approach or need. And yet others are due to the chronology of events that led up to the recipesâ€™ creation. I think you can learn a lot about writing AutoPkg recipes by just examining these recipe sets. Itâ€™s worthy of multiple blog posts, and will be an important part of <a href="https://conference.mactech.com/sessions/" target="_blank">my talk at the upcoming MacTech Conference</a> in Los Angeles this October.</p>
<p>In this post, I want to focus on just one small detail: for a suite or family of applications, do you write one recipe that can download many products or write individual recipes for each product? What do the existing Microsoft product recipes do?</p>
<h3>Variations on a Theme</h3>
<p><a href="https://github.com/autopkg/rtrouton-recipes" target="_blank">Rich Troutonâ€™s recipes</a> take the one-recipe-per-product approach. In most cases, these recipes use a single template and then just change one default Input value (the FWLink number from Microsoft) to make it point to the desired product. There are some significant benefits to doing it this way.</p>
<p>First is ease of use. The recipe already contains the correct Input value for the product; the user doesnâ€™t have to look it up like they would with a non-specific recipe. Second is discoverability. It allows you to put the specific product name in the recipe title and/or identifier (e.g., Excel, PowerPoint) so that people searching for a recipe (<code>autopkg search</code>) are more likely to find it. Then there are smaller benefits, like being able to add more recipes for more products without much effort (like Rich did when my <a href="/2019/05/18/office-autopkg-recipes-update.html" target="_blank">previous post on this topic</a> showed that there were three products he didnâ€™t have recipes for yet). As well, some workflows really benefit from having named recipes â€” Iâ€™m thinking specifically of a shop like dataJAR, where they are supporting multiple clients, so theyâ€™re not just managing overrides for a single client.</p>
<h3 id="master">A Kind of Master</h3>
<p>The recipes in the <a href="https://github.com/autopkg/recipes/tree/master/MSOfficeUpdates" target="_blank">core AutoPkg recipes repo</a> take a clever hybrid approach: there is one master recipe (<a href="https://github.com/autopkg/recipes/blob/master/MSOfficeUpdates/MSOfficeMacProduct.download.recipe" target="_blank">MSOfficeMacProduct.download.recipe</a>), but individual download recipes also exist for all supported products. <a href="https://github.com/autopkg/recipes/blob/master/MSOfficeUpdates/MSExcel2019.download.recipe" target="_blank">Take a look at one of those product download recipes</a> and what do you notice? It is a child of the master download recipe which executes <em>no additional steps;</em> there is literally no <code>Process</code> section present!</p>
<p>This exposes something very interesting about how AutoPkg deals with variables declared in the Input section: if the same variable name appears in more than one recipe in the chain, it will adopt the value that appears last in the chain that you run. The core recipes leverage this to set the value of the <code>PRODUCT</code> variable to the one associated with the desired product.<a href="#foot1" id="ref1"><sup>[1]</sup></a> So with this clever trick, there is only one master download recipe to maintain, but you get all the benefits mentioned above.</p>
<p>Of course, the child recipes further down the chain (<code>.munki</code> in this repo) have to be written using a template, but those recipes generally supply information for your management system that differs enough for each product to make it worth the effort. So this is still a pretty effective solution for the products that the core recipes support.</p>
<h3>One Recipe to Rule Them All</h3>
<p>But can we minimize maintenance even further? If I can write one recipe that can download different products or versions by simply changing a particular Input value in my override, then I only have to maintain that one recipe. This is an approach I have taken with a number of other recipes I have written. Sometimes, itâ€™s about offering <a href="https://github.com/autopkg/jazzace-recipes/blob/master/QSRInternational/NVivo.download.recipe" target="_blank">a different major version</a> or a different level of functionality (e.g., standard vs. Pro) or <a href="https://github.com/autopkg/jazzace-recipes/blob/master/Ableton/AbletonLive.download.recipe" target="_blank">both</a>. In the case of Office, the fixed links for download of Office products are very similar, so you could definitely take this approach. In fact, for my own personal Office downloading, I have done just that.</p>
<p>I wrote a single download recipe (<a href="https://github.com/autopkg/jazzace-recipes/blob/master/Microsoft/MicrosoftMacProductFWLink.download.recipe" target="_blank">MicrosoftMacProductFWLink.download.recipe</a>) that can download any Microsoft product with a FWLink value. I then added one child recipe in order to copy the downloaded installer package to a local directory (in the future, I may create a recipe to move the package into a management system and/or pick up version information). Since you can make multiple overrides of a single recipe<a href="#foot2" id="ref2"><sup>[2]</sup></a>, I made one override for the Suite and 5 different individual product recipe overrides. I changed the Input value for <code>PRODUCTID</code> to the FWLink value I need for that product in each override.</p>
<p>If Microsoft changes any of the FWLink values (as they did somewhat in the transition from Office 2016 to 2019), I can change the value of <code>PRODUCTID</code> in the override and Iâ€™m done. If Microsoft changes their URL scheme but continues basing it on FWLink values, then I can patch just one download recipe and be rolling again. Simple.</p>
<p>If thereâ€™s a down side to this method, itâ€™s that it requires more operator skill. For the recipe author, thatâ€™s no problem (at least initially). If I want to share it, however, I have to document it clearly and trust that other users will read the documentation. As I mentioned earlier, itâ€™s also hard to find if you are looking for, say, an Excel recipe using <code>autopkg search</code>, since that product name does not appear anywhere in the recipe (even though thatâ€™s the recipe I personally use for that product).</p>
<p>I want to be clear that <em>I am not recommending that anyone adopt my method for Office recipes.</em> There are many good reasons to use one of the existing sets of recipes, including the fact that I expect them to be maintained. I am just including them here as a proof of concept â€” the techniques may be useful to you when you are conceiving of how you might write recipes for other products.</p>
<h3 id="constants">Input Variables as Constantsâ€¦</h3>
<p>You may have notices that none of the individual Microsoft product recipes (found in the core recipes and Rich Trouton recipes repos) hardcode product-specific values into the <code>Process</code> section of the recipes. They use an Input variable as a kind of constant. In fact, the Rich Trouton and <a href="https://github.com/arubdesu/office-recipes" target="_blank">Allister Banks-hosted (arubdesu)</a> recipes use the Microsoft download URL as such a constant as well. I actually wish we could declare constants in AutoPkg recipes. Using constants (that recipes users could not override) could make recipes more readable and, when used more than once in a recipe, easier to update. Coders do this instinctively, which is why we see this technique in many other AutoPkg recipes.</p>
<p>Nevertheless, because these are actually variables, users can override their value. This was a plus for the Office suite download recipe in the arubdesu-recipes repo when Microsoft moved from 2016 to 2019; one could simply change the value of a specific Input key to the updated FWLink number from Microsoft and get a (mostly) functional recipe. The down side of using variables as constants is that, when the recipe author updates an Input variable value in the original recipe, someone who has an override in place does not receive the updated value. This was a bigger deal before Trust Verification came into being, when many users would accept recipe updates from others willy nilly. (There arenâ€™t any of those people left, are there?) Now users who are auditing changed recipes will still see that there is a change, but they will have to manually copy the changed value(s) over to their override or create a new override, which will then take the new values as default. [Update: A useful technique with constants is to remove them from your override, so that the authorâ€™s value is always used. More details can be found in <a href="/2019/11/11/autopkg-input-variables.html#omitinput" target="_blank">this more recent post</a>.]</p>
<p>On the flip side, moving those pseudo-constants out of the Input section and into the Process section as hardcoded values means that when you as an author update a recipe, you know that users (including yourself) will get the update next time they update their copy of your repo â€” no handstands required. It does mean that a pull request or an an update by the maintainer(s) is required for a fix, however. Weâ€™ve already seen in the past two transitions of Office recipes that certain recipes didnâ€™t get updated until the maintainers had access to the new products and needed to deploy them, so both approaches have their liabilities. In general, we are seeing recipe authors move away from putting URLs and regular expressions in the Input section as variables.</p>
<p>Someone using the FWLink download method could reasonably argue that yet another set of Office recipes should be written with fixed links in the Process section for every product, as this is the most fault-resistant method (if you want full installers), but I donâ€™t think thereâ€™s any reason to muddy the waters now. We donâ€™t expect any significant changes from Microsoft until they release their next perpetual version of Office in, say 2022, so as long as users understand what these recipes are doing when the next change comes along, weâ€™ll be fine.</p>
<h3>More To Learn</h3>
<p>For those who follow me on Twitter, you know that every time I thought I was done a post, I kept finding something worth further comment in these recipes. The post I was working on at the time wasnâ€™t this one â€” I determined that I needed to start a new post from scratch for this topic. So Iâ€™ve got one or two more blog posts to come on these recipes, including the pros and cons of using custom processors versus just the core processors. I look forward to bringing you those soon.</p>
<p><cite>Updated 2019-11-11 to add another technique for dealing with constants.</cite></p>
<hr/>
<p id="foot1">[1] In fact, you canâ€™t even run the parent recipe on its own, as the default value for <code>PRODUCT</code> is not considered to be valid by the custom processor. <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] Make certain you change the identifier and filename of each override to make them unique. If youâ€™re using AutoPkgr to make your override, change the recipe name when prompted as you create the override; when using <code>autopkg make-override</code>, use the <code>-n</code> flag to specify the recipe name. In both methods, the identifier and recipe name will both be set based on the value supplied. <a href="#ref2">[Return to main text]</a></p>