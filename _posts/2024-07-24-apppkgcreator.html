---
layout: post
title: üì¶ When AppPkgCreator Isn‚Äôt Enough
---
<p>Recently, I was asked to deploy an app that is supplied as a drag-and-drop app in a disk image (.dmg). Luckily for me, someone had already written download and pkg AutoPkg recipes for it, so I just had to add a child recipe to upload to my management system.</p>
<h3>Except‚Ä¶</h3>
<p>The open source developer of this app provides separate downloads for Intel and Apple Silicon CPUs (I still have to support both architectures). There are two ways to workaround the lack of a Universal macOS installer:</p>
<ul><li><strong>Create one yourself</strong>: you can use AutoPkg to gather up (or create) the architecture-dependent installers for both and use a postinstall script to check the architecture and then install the correct one (see examples from <a href="https://github.com/autopkg/rtrouton-recipes/tree/master/AdobeCreativeCloud" target="_blank">Rich Trouton</a> and <a href="https://github.com/autopkg/smithjw-recipes/tree/master/Docker" target="_blank">James Smith</a>); or</li>
<li><strong>Create two overrides</strong><a href="#foot1" id="ref1"><sup>[1]</sup></a>, one for Intel, one for Apple Silicon, change the input variables appropriately, and have your management system deploy them to the appropriate computers.</li>
</ul>
<p>I chose the second option, as AutoPkg can create the commands in my management system via API that will deploy these appropriately.<a href="#foot2" id="ref2"><sup>[2]</sup></a> But there was one small snag: the existing pkg recipe consisted of a single step: AppPkgCreator. Normally, this is perfect for packaging apps that come in a disk image. You can often run the recipe without supplying any arguments, as was the case with the pkg recipe I wanted to use. But take a look at the <code>pkg_path</code> argument from the AppPkgCreator processor information:</p> 
<pre>pkg_path:
     required: False
     description: The pathname for the pkg to be created. If not set, 
         defaults to %RECIPE_CACHE_DIR%/%app_name%-%version%.pkg</pre>
<p>The problem is that making two overrides does not allow me to change the name, since it uses the name from the app bundle, which is the same regardless of architecture. My management system cannot deal with two identical names for the different packages, so I have to modify the pkg recipe to get around this.</p>
<h3>You would think this would work‚Ä¶</h3>
<p>The most obvious solution would appear to be to keep the AppPkgCreator processor but add the <code>pkg_path</code> argument, using a value of <code>%RECIPE_CACHE_DIR%/%NAME%-%version%.pkg</code>, where I would change the value of <code>NAME</code> in the Input variables on my overrides to something like ‚ÄúAppName-Intel‚Äù and ‚ÄúAppName-AppleSilicon‚Äù respectively. But this doesn‚Äôt work.</p>
<p>This is because AutoPkg evaluates the arguments supplied to any processor before any of the processor‚Äôs unique code is run. In my situation, <code>version</code> has not been set, so AutoPkg reports an error:</p>
<pre>Use of undefined key in variable substitution: 'version'</pre>
<p>So how to we work around this? There are three ways, all of which produce the same resulting package.</p>
<h3>Technique 1: Rename the package after creation</h3>
<p>I could add a step to the pkg recipe that renames the package created. (In fact, I could leave the existing pkg recipe untouched and write an additional child recipe with the needed step if I preferred.) FileMover or PkgCopier are two obvious options, with the difference being that PkgCopier leaves behind an extra copy of the pkg (which is no big deal if you are using an APFS volume). It turns out that using FileMover is not a good choice because AppPkgCreator will not find the pkg it built on a previous run once the name is changed and will rebuild it on each run. (The same applies if you use PkgCopier and decide you want to remove the original pkg with PathDeleter afterwards.)</p>
<h3>Technique 2: Prefetch the version information</h3>
<p>Another way is to solve the ‚Äúundefined key‚Äù problem by grabbing the app version before asking for the app to be packaged. Again, there are two processors that can do this: Versioner and AppDmgVersioner. As you might suspect, AppDmgVersioner was built for this exact situation, so as long as the vendor hasn‚Äôt done something silly with the version number that requires the use of the advanced features of Versioner, this is the simplest option. Once we have fetched the version this way, we can use the <code>pkg_path</code> argument for AppPkgCreator that we tried originally and it will now behave as expected.</p>
<h3>Technique 3: Old School</h3>
<p>Finally, you can do this the way you <em>had</em> to do it prior to <code>AppPkgCreator</code> being added to AutoPkg in version 1.0: you manually create the package. You can still see some examples of this technique in the core recipes repo, like the <a href="https://github.com/autopkg/recipes/blob/master/Mozilla/Firefox.pkg.recipe" target="_blank">Firefox.pkg recipe</a>.<a href="#foot3" id="ref3"><sup>[3]</sup></a> In fact, I literally copied the body of that recipe into a new recipe, tweaked it as necessary, and was able to create the same package as with the other techniques. It is a little more involved from a writing perspective, but there is original art to copy, so it‚Äôs not really harder to do (perhaps harder to read). In theory, it‚Äôs the most efficient technique of the three, but the performance advantage is minor, as the code in AppPkgCreator will not do needless work if the variables it would capture automatically are already in the environment as the result of an earlier processor or a processor argument.</p>
<h3>P.S.: Installer Bundle Identifier</h3>
<p>In all of these techniques, the package for each architecture will have the same identifier, since it picks up the identifier of the app itself and uses that. If you want your install receipt to show which package/architecture you installed, you will need to use the <code>bundleid</code> argument with AppPkgCreator or the <code>id</code> argument with PkgCreator ‚Äî appending the value of the architecture input variable to the app‚Äôs bundle ID using variable substitution would be a good option here.</p>
<h3>In the end‚Ä¶</h3>
<p>For the specific situation I came across, I decided to go with Technique 2 and asked the original author whether they wanted me to submit a Pull Request or whether I should just create a new pkg recipe in my own repo. They opted for the PR, which makes me happy, because there is certainly a preference for eliminating duplication from the maintainers.</p>
<p>You can see all the recipes that I created to test these techniques (using <a href="https://github.com/autopkg/aanklewicz-recipes/blob/f52ea2936fbc5c642843f18a6aad068a5e686f22/SonicPi/SonicPi.download.recipe" target="_blank">SonicPi.download</a> as the parent) as a <a href="https://gist.github.com/jazzace/97d28827929f9f43de490b2b25dd4176" target="_blank">Gist on GitHub</a>. This Gist also includes instructions on what to add if you want to have unique IDs for each package.</p>
<p>This was a fairly simple case, but I thought it was worth sharing as an example of how variable substitution does and doesn‚Äôt work in AutoPkg and how there are many ways to get the output you want when a processor doesn‚Äôt do exactly what you need.</p>
<hr/>
<p id="foot1">[1] In case you haven‚Äôt made more than one override of a recipe, you want to use the <code>-n</code> option when making your override. In this case, it might be: 
<pre>autopkg make-override AppName.pkg -n AppName-Intel.pkg
autopkg make-override AppName.pkg -n AppName-AppleSilicon.pkg</pre>
If you make your overrides with AutoPkgr, it will prompt you for a name, which you enter just like the <code>-n</code> option above. <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] For those of you who follow my work, you will know that my management system is Jamf Pro and I am leveraging the JamfUploader processors to upload packages and create policies. This is the reason I require a package installer. But the principles being discussed apply generally. <a href="#ref2">[Return to main text]</a></p>
<p id="foot3">[3] Most people don‚Äôt use this recipe any more since Mozilla started offering a signed pkg installer (which the FirefoxSignedPkg recipes in that repo leverage). <a href="#ref3">[Return to main text]</a></p>
