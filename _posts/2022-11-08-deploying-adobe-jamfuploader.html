---
layout: post
title: üì¶ Deploying Adobe Software with JamfUploader
---
<p>This past weekend, Darren Wallace posted a <a href="https://dazwallace.wordpress.com/2022/11/06/recommended-workflow-to-deploy-adobe-software-with-jamf-pro/" target="_blank">Recommended workflow to deploy Adobe software with Jamf Pro.</a> It nicely describes everything step-by-step and has appendices that deal with some common issues. If you haven‚Äôt read this yet, go do that now, as this post should be considered to be an adjunct to Darren‚Äôs. I‚Äôm going to describe how I replace some of the manual steps in Darren‚Äôs workflow by using AutoPkg and JamfUploader. Let me follow the same format as Darren‚Äôs post:</p>
<ol><li>Obtaining your Adobe Packages</li>
<li>Uploading to Jamf Pro</li>
<li>Deployment</li>
</ol>
<h3>Obtaining your Adobe Packages</h3>
<p>My process is exactly the same as Darren‚Äôs: create a single-app ‚Äúpackage‚Äù from the Adobe console, download the generated disk image, run the Adobe Package Downloader app from the mounted disk image, and manually uncompress the zipped payload that Adobe Package Downloader downloads. The only thing that is important to note is that I use the default location for downloading with Adobe Package Downloader, namely <code>~/Downloads</code>.
<h3>Uploading to Jamf Pro</h3>
<p>I used to do it the same way as Darren suggests ‚Äî specifically, I uploaded the Install pkg using Jamf Admin, which automatically took care of zipping the pkg. Now I have AutoPkg automate this part of the process.<a href="#foot1" id="ref1"><sup>[1]</sup></a> The automation does the following:</p>
<ol><li>Locates the Install.pkg on the local system.</li>
<li>Determines the version of the app in the pkg.</li>
<li>Renames the pkg filename by appending the version number to the name.</li>
<li>Uploads the pkg using the JamfPackageUploader processor in AutoPkg.</li>
</ol>
<p>The first two steps are handled nicely by using the <a href="https://github.com/autopkg/dataJAR-recipes/blob/master/Adobe%20Admin%20Console%20Packages/AdobeAdminConsolePackagesPkgInfoCreator.py" target="_blank">AdobeAdminConsolePackagesPkgInfoCreator custom processor written by the folks at dataJAR</a>. Even though they wrote that processor in the context of preparing Adobe packages for Munki, it works for this workflow as well. AdobeAdminConsolePackagesPkgInfoCreator has two dependencies:</p>
<ul><li>The <code>NAME</code> input variable must match the name you used in the Adobe Admin Console when creating the ‚Äúpackage‚Äù, and</li>
<li>The expanded archive must be located in <code>~/Downloads</code>.</li>
</ul>
<p>For my automation, I used the Old School method of writing a single recipe that I would override with different Input values (for <code>NAME</code>) for each product.<a href="#foot2" id="ref2"><sup>[2]</sup></a> That recipe is <a href="https://github.com/autopkg/jazzace-recipes/blob/master/AdobeAdminConsole/AdobeAdminConsole.pkg.recipe" target="_blank">AdobeAdminConsole.pkg.recipe</a>. Because AdobeAdminConsolePackagesPkgInfoCreator collects the version number, I can use that to rename my Adobe installer pkg. So my AutoPkg .pkg recipe has two processor steps:</p>
<ol><li><cite>Processor:</cite> com.github.dataJAR-recipes.munki.Adobe Lightroom Classic/AdobeAdminConsolePackagesPkgInfoCreator<br/>
<cite>Result:</cite> Values returned for <code>aacp_install_pkg_path</code> and <code>version</code></li>
<li><cite>Processor:</cite> PkgCopier<br/>
<cite>Result:</cite> <code>pkg_path</code> (renamed pkg) set to <code>NAME-version.pkg</code></li>
</ol>
<p>Since I run AutoPkg on an APFS system, duplicating the large installer pkg (so that I can change the name) does not take up any significant space. As an added bonus, using <code>PkgCopier</code> sets the variable <code>pkg_path</code> to the location of the renamed pkg installer, which is what other processors (<code>JamfPackageUploader</code>, in this case) expect.</p>
<p>The final part of automating the upload is using the <code>JamfPackageUploader</code> processor. Using standard AutoPkg authoring practices, I created a new .jamf recipe with that processor whose parent is my AdobeAdminConsole.pkg recipe.<a href="#foot3" id="ref3"><sup>[3]</sup></a> <code>JamfPackageUploader</code> takes care of zipping the Adobe pkg installer, so you do not have to do that manually.</p>
<h3>Deployment</h3>
<p>My context is that I am running a shared computer lab; Self Service is not in the picture. So for all the Adobe apps that I wish to deploy, I use a Jamf Pro policy that installs the Adobe app on enrolment (or on next check-in if scoped after enrolment) and, in case of failure, retries the installation up to 2 more times before giving up. Once successfully installed, I then use Adobe‚Äôs Remote Update Manager (RUM) to keep the apps up to date until I deploy the next major version. Let me break that down into the policies I use to make that happen:</p>
<ul><li><cite>SITE</cite> Adobe <cite>AppName AppYear</cite> Latest [one per app]</li>
<li>Adobe Update Install via RUM</li>
</ul>
<p>Prior to using the JamfUploader processors, I used a single, manually-crafted policy to deploy all eight apps that we support. This was still more flexible than creating a multi-app Adobe package because if only one or two apps got an update, I could just substitute updated packages for those apps. But as Darren‚Äôs article mentioned, installation failures can and do happen. In that previous scenario, if one app failed to install, it tried to reinstall <em>every</em> app on the next attempt. The real beauty of automating the policy creation with AutoPkg and the <code>JamfPolicyUploader</code> processor is that I can create a separate policy for each app with very little effort. Then, any retries are efficient and it is easier to track what failed.</p>
<p>Thus, the rest of my .jamf recipe (after the <code>JamfPackageUploader</code> processor) follows a standard pattern:</p>
<ol><li value=2><cite>Processor:</cite> StopProcessingIf<br/>
<cite>Result:</cite> Recipe stops if <code>pkg_uploaded == False</code></li>
<li><cite>Processor:</cite> com.github.grahampugh.jamf-upload.processors/JamfPolicyUploader<br/>
<cite>Result:</cite> Policy is created/replaced based on the template specified</li>
</ol>
<p>I then override the .jamf recipe multiple times ‚Äî once for each Adobe product I am deploying. For example, I would create an override for Photoshop 2023 like this:<a href="#foot4" id="ref4"><sup>[4]</sup></a><a href="#foot5" id="ref5"><sup>[5]</sup></a></p>  
<pre>autopkg make-override AdobeAdminConsole-latest.jamf -n AdobePhotoshop2023-latest.jamf</pre>
<p>I would then go in to the newly-created override and change the <code>NAME</code> Input variable value to match the name I gave the ‚Äúpackage‚Äù in the Adobe Admin Console, which in my case looks something like <code>SDL_Photoshop_2023</code>. Once the overrides are created, all I need to do to update that app in Jamf Pro is to download the new version from the Adobe Admin Console, unzip it, and then run the override. The new pkg installer will be uploaded, versioned, and my policy will be updated with the new pkg.</p>
<p>Finally, I mentioned that I only use the Jamf Pro policies created through this process to do the initial install. I have one hand-crafted Jamf Pro policy that runs RUM once every week (I guess you could call it a RUM runner üòÜ). It is a policy that runs a single command using the Files and Processes payload. In the Execute Command field, I entered this:</p>
<pre>/usr/local/bin/RemoteUpdateManager --action=install</pre>
<p>That triggers RUM to install any available (minor version) updates. If you want to know more about RUM, <a href="https://dazwallace.wordpress.com/2021/04/06/adobe-remote-update-manager/" target="_blank">Darren has an excellent blog post on it as well</a>.</p>
<h3>TL;DR</h3>
<p>If this post was more detailed than you would like and you just want a list of steps to follow to make this happen, I have a <a href="https://github.com/autopkg/jazzace-recipes/tree/master/AdobeAdminConsole" target="_blank">ReadMe in my repo along side the AdobeAdminConsole.pkg and .jamf recipes</a> I have discussed here that does just that (excluding the discussion of RUM). But I hope that this post both supplements what Darren had to say on this topic and gives you a little more insight into what I am doing so that you can decide which parts of my workflow might be useful in your context.</p> 
<hr/>
<p id="foot1">[1] In my case, I use the same Mac that runs AutoPkg to download installers from the Adobe Admin Console. That makes it work easily with the AdobeAdminConsolePackagesPkgInfoCreator processor. If you need to use separate computers for those two tasks, take note of the appendix in Darren‚Äôs post regarding <a href="https://dazwallace.wordpress.com/2022/11/06/recommended-workflow-to-deploy-adobe-software-with-jamf-pro/#appendix-3-moving-downloaded-adobe-packages-prior-to-upload" target="_blank">Moving downloaded Adobe packages prior to upload</a>. <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] In the <a href="https://github.com/autopkg/dataJAR-recipes/tree/master/Adobe%20Admin%20Console%20Packages" target="_blank">dataJAR .munki recipes</a>, they provide a recipe for each product that uses a documented naming convention. (These recipes are duplicates of each other with the <code>NAME</code> variable and Description changed.) What I determined when looking at their code is that you could use <em>any</em> value for <code>NAME</code>; Munki users could override the dataJAR recipes to use a different naming convention, as long as it matched the name used in the console when creating the ‚Äúpackage.‚Äù So the fact that I didn‚Äôt use their naming convention (or that I didn‚Äôt use Munki) did not prevent me from using their processor because of the flexible way in which it was written. <a href="#ref2">[Return to main text]</a></p>
<p id="foot3">[3] Since I want my recipe to fail if the <code>pkg_category</code> I supply does not exist on my Jamf Pro instance, I use the <code>JamfPackageUploader</code> processor on its own, but you may choose to precede it with a <code>JamfCategoryUploader</code> processor if you would prefer that the category be created if it is not present. <a href="#ref3">[Return to main text]</a></p>
<p id="foot4">[4] You can also make the override in AutoPkgr by Control- or Right-clicking on the AdobeAdminConsole.pkg recipe from the list of recipes, selecting Create Override from the contextual menu, and then renaming the override when prompted. It uses the exact same AutoPkg command under the hood to create the override. <a href="#ref4">[Return to main text]</a></p>
<p id="foot5">[5] By convention, any .jamf recipe that doesn‚Äôt match the functionality of an old .jss recipe has an additional label added, in the form of <code>RecipeName-label.jamf.recipe</code>. In my case, a recipe whose goal is to create/update a Jamf Pro policy so that it has the latest version of the app installer as its payload gets the label <code>latest</code>. I discuss my naming convention in more detail in the <a href="/2022/07/14/jamfuploader.html" target="_blank">presentation I did with Graham Pugh for the Mac Admins 2022 Campfire Sessions</a> ‚Äî see Slide 29. <a href="#ref5">[Return to main text]</a></p>