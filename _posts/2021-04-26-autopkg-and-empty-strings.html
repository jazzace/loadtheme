---
layout: post
title: üì¶ AutoPkg, Variable Persistence, and Empty Strings
---
<p>This is one of the simpler things I‚Äôve learned about how AutoPkg works, but I‚Äôm sharing it here in case it happens to meet a use case of yours. When setting arguments for a processor, you can set the value of a variable to an empty string (<code>&lt;string/&gt;</code> or <code>&lt;string&gt;&lt;/string&gt;</code>) to ensure that the processor ignores any value for that variable that had been previously set in the recipe (e.g., as output from another processor). Let me explain how that might be useful.</p>
<h3>The Principle of Persistence</h3>
<p>In AutoPkg, once a variable exists within the run of a recipe, it persists until the end of the run. (It inherits this property from the Python language in which it is built.) This has potentially beneficial side effects. For example, a common start to a download recipe is to call a processor that fetches the URL of the product to be downloaded (e.g., custom processor, <code>URLTextSearcher</code>) immediately followed by the <code>URLDownloader</code> processor. In some cases, that <code>URLDownloader</code> processor is called without any arguments. But how can that be? The <a href="https://github.com/autopkg/autopkg/wiki/Processor-URLDownloader" target="_blank"><code>processor-info</code> for <code>URLDownloader</code></a> states that the <code>url</code> variable is <em>required</em>.</p>
<p>In those instances, it‚Äôs because the previous processor returned the URL in an output variable named <code>url</code>. The <code>URLDownloader</code> processor doesn‚Äôt ask, ‚Äúhas the user added the <code>url</code> argument to the Arguments dictionary?‚Äù Instead, it asks, ‚Äúwhat is the value of the variable <code>url</code>?‚Äù If that variable has been assigned a value <em>any time</em> prior to the processor call (including as an argument to that processor), AutoPkg will use it. (This applies whether the input variable is optional or required.) This can make recipes less verbose, since processor authors often create output variable names that pair nicely with input variable names of other processors.</p>
<h3>When Persistence is Problematic</h3>
<p>Having said this, this persistence could also lead to an unanticipated result in a later processor if you didn‚Äôt realize that a particular variable had been set. Here‚Äôs a concrete example using the recipes available for MeshLab. The <a href="https://github.com/autopkg/hansen-m-recipes/blob/master/MeshLab/MeshLab.download.recipe" target="_blank">download recipe (from the hansen-m-recipes repo)</a> uses the <code>GitHubReleasesInfoProvider</code> processor to obtain the download URL. That processor returns three output variables: <code>release_notes</code>, <code>url</code>, and <code>version</code>. So when the next processor, <code>URLDownloader</code>, looks for the <code>url</code> variable, it finds that the value it needs has already been set.</p>
<p>I need a pkg installer to deploy MeshLab with my management system, so I created a pkg child recipe. Because the app is nicely contained in a disk image, I used the <code>AppPkgCreator</code> processor to do all the work. <code>AppPkgCreator</code> will not only bundle the app in a pkg installer but it will also grab the version number from the app to use in naming and versioning the package. But here‚Äôs where the side effect comes in. If you specify the value for <code>version</code> (as an Argument to the processor, for instance), the processor will use that instead. In this case, since the <code>GitHubReleasesInfoProvider</code> processor set the value for <code>version</code>, that is what <code>AppPkgCreator</code> will use for the version number; it will not try to extract it from the app itself.</p>
<p>Often, this does not cause a problem because the value would be the same. In the case of MeshLab, however, <code>GitHubReleasesInfoProvider</code> considers the version to be ‚ÄúMeshLab-‚Äù followed by what we think of as the version number. So when <code>AppPkgCreator</code> gets called, it uses that as the version number. That‚Äôs not what I want. Initially, my solution was to use <a href="https://github.com/autopkg/homebysix-recipes/tree/master/FindAndReplace" target="_blank">Elliot Jordan‚Äôs FindAndReplace shared processor</a> to get rid of the ‚ÄúMeshLab-‚Äù in the version number just before calling <code>AppPkgCreator</code>. A kind <a href="https://github.com/autopkg/jazzace-recipes/pull/26" target="_blank">pull request from James Reynolds</a> suggested using the <code>AppDmgVersioner</code> processor to grab the correct version instead. Both of these work, but I knew that <code>AppPkgCreator</code> had a versioning routine built in. So I wondered what would happen if I didn‚Äôt implement either of those solutions but instead set the value of <code>version</code> to an empty string in the Arguments section of the <code>AppPkgCreator</code> processor call, like so:</p>
<pre>&lt;dict&gt;
	&lt;key&gt;Processor&lt;/key&gt;
	&lt;string&gt;AppPkgCreator&lt;/string&gt;
	&lt;key&gt;Arguments&lt;/key&gt;
	&lt;dict&gt;
		&lt;key&gt;version&lt;/key&gt;
		&lt;string/&gt;
	&lt;/dict&gt;
&lt;/dict&gt;
</pre>
Or, if you‚Äôre using YAML recipes:
<pre>- Processor: AppPkgCreator
  Arguments:
    version: ''
</pre>
<p>As it turned out, <code>AppPkgCreator</code> interpreted a null value for <code>version</code> in the same way as if <code>version</code> had never been set. As I am beginning to learn, this aligns with the truthiness principle of the Python language, where strings are evaluated as True if they contain any characters and False if they are completely empty. In this case, clearing the value for <code>version</code> made the processor run its internal routine to grab the version number from the app bundle. <a href="https://github.com/autopkg/jazzace-recipes/blob/master/MeshLab/MeshLab.pkg.recipe" target="_blank">This became the cleanest way</a> to make certain I obtained the correct version number for my pkg.</p>
<h3>Variables are (still) Arbitrary</h3>
<p>This principle is a good corollary to the one I <a href="https://maclabs.jazzace.ca/2020/06/04/things-i-learned-autopkg.html" target="_blank">spoke about at the 2020 Mac Admins Campfire Sessions</a>: variables are arbitrary. The Arguments dictionary for each processor is simply a way to establish variables and their value. For readability, we pair those Arguments with the processor that is going to use them. But variables are also created/set from the output of processors. AutoPkg will use anything that is available in the environment in which it is running. What I learned this month was that I could eliminate a previous value using a null string to trigger (or avoid triggering) an option in a processor call. I hope that this discussion helps you both read recipes more easily (uncovering the ‚Äúhidden‚Äù variables that processors use) and provides an additional technique for you to use, even if just for debugging.</p>