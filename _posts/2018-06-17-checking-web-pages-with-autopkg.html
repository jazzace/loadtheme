---
layout: post
title: üì¶ Checking Web Pages with AutoPkg
---
<p>As I detailed in <a href="/2018/05/31/imaging-is-more-dead.html">my previous post,</a> I noticed (by chance) that an Apple Support Article that was important to system administrators had changed significantly. A number of presentations at the <a href="https://www.macad.uk" target="_blank">MacAD.UK</a> conference in February (including mine) quoted this Article. Apparently, it had changed 18 days before I discovered the change<a href="#foot1" id="ref1"><sup>[1]</sup></a>. The timing of this update wasn‚Äôt aligned with any particular OS or security update, so it‚Äôs no wonder it took a while to find. Still, it seemed like there should be a way to automatically check on an Article like that one so that it doesn‚Äôt sit there unnoticed by the community.</p>
<p>What tools do I use as a Mac Administrator to check for updates? Well, there‚Äôs Apple‚Äôs Software Update (soon to be moved from the Mac App Store back to System Preferences). Apple also has an <a href="feed://developer.apple.com/news/releases/rss/releases.rss" target="_blank">RSS Feed for Developers</a> that mentions OS releases but there‚Äôs nothing for Support Articles. There‚Äôs always the Mac Admins Slack and Twitter, of course, but that is not at all systematic. So my mind went to the tool that I use to check on software updates not covered by Apple‚Äôs mechanisms: <a href="https://github.com/autopkg/autopkg" target="_blank">AutoPkg.</a> Could the <code>URLDownloader</code> processor also be used to check for updates to web pages? The answer, I found out, was ‚ÄúYes, but‚Ä¶.‚Äù Let me take you through my process. (This is also partially meant as a tutorial for people learning to write AutoPkg recipes, so apologies to readers fluent in this area for the depth of detail.) If you‚Äôre OK with spoilers, you can <a href="https://github.com/autopkg/jazzace-recipes/blob/master/AppleSupport/AppleSupportArticle.download.recipe" target="_blank">follow along with the finished recipe.</a></p>
<h3>Building the Recipe</h3>
<p>The goal was for the recipe user to specify the ID for the Article (e.g., HT208020 for the article I mentioned off the top) and have AutoPkg do the rest. This is similar to the approach <a href="https://github.com/autopkg/n8felton-recipes" target="_blank">Nate Felton</a> used when developing his <code>AppleSupportDownloadInfoProvider</code> custom processor, only that the page was what we wanted to download, not a link within the page (hence, no need for a custom processor). AutoPkg would then retain a copy of the Article such that, when the next update came, the user could then compare the changes because they had both files in hand.</p>
<p>So the first test was to see if the <code>URLDownloader</code> processor would actually save the page/item if it URL wasn‚Äôt pointing to an installer or a disk image or an archive of some sort. Happily, the answer was yes. The URL format for Apple Support Articles is such that the kind of file being saved is not specified by an extension, so the file that <code>URLDownloader</code> cached did not have an extension on it either. No matter; a quick examination determined that it was HTML. When I viewed the cached file in a web browser, it wasn‚Äôt nearly as pretty as the normal Apple version<a href="#foot2" id="ref2"><sup>[2]</sup></a>, but the content was clearly there. As is my normal process in developing recipes, I then ran it again and the recipe correctly determined that there had been no changes since the last run. Success! This could work!</p>
<p>Next was the task of archiving a copy in some way. I noticed that there was a ‚ÄúPublished Date‚Äù at the bottom of each Article. I‚Äôve used <code>URLTextSearcher</code> before to find specific links on a page, so I used it to find that date, which would always follow the words ‚ÄúPublished Date:‚Äù. Strangely, the date wasn‚Äôt in the format displayed on the page‚ÄîJavascript modified it for output‚Äîbut it was completely consistent. The HTML block that I would need to locate looked like this:</p>
<pre>&lt;div itemProp="dateModified" class="mod-date"&gt;&lt;span&gt;Published Date:&lt;/span&gt;
&lt;span itemProp="dateModified"&gt;Thu May 10 15:53:48 GMT 2018&lt;/span&gt;&lt;/div&gt;</pre>
<p>I simplified that search such that I took just enough of the markup before the date to make certain I found the right string. Using <strike>trial and error</strike> the power of regular expressions, I captured that date, but I also used a trick I picked up from someone else‚Äôs recipe (I think it was in the main AutoPkg recipes repo) to assign different parts of the string to different variables. So my <code>re_pattern</code> looked like this:</p>
<pre>itemProp="dateModified"&amp;gt;(?P&amp;lt;version&amp;gt;[^:]*):(?P&amp;lt;mm&amp;gt;..):.. ... (?P&amp;lt;yr&amp;gt;....)</pre>
<p>That would assign all of the date string up to the first colon (e.g., <code>Thu May 10 15</code>) to <code>version</code>, the minutes of the timestamp to <code>mm</code>, and the four-digit year to <code>yr</code>.<a href="#foot3" id="ref3"><sup>[3]</sup></a> I then used those variables to build an output filename more to my liking. (I could have just captured the whole date+timestamp and used it as is, but I wanted the year first and I wanted it to say UTC not GMT, being the pedant that I am.)</p>
<p>A subtle detail here: Normally, I would provide <code>URLTextSearcher</code> a URL for a web page. I could certainly have had AutoPkg download this page redundantly to perform the search for the date+timestamp, but I decided to see if using a local reference (<code>file:///</code>) would work. It did. In addition to eliminating a redundant download, this method accounts for the rare instance when the page might change in the split second between the two calls to fetch the page.</p>
<p>I used the <code>Copier</code> processor to move the downloaded file to a directory that the recipe user specified in the Input <code>dict</code>, renaming the file with the Article Number, formatted date+time information, and an .html extension. Since I was trying to avoid using a custom processor (particularly since I can‚Äôt code in Python‚Ä¶ yet), I just documented in the recipe description that the path should exist (since the recipe could fail otherwise).</p>
<h3>Enhancements</h3>
<p>I now had a working recipe as far as I could tell. I chose to add two more features:</p>
<ol><li>Users must specify the language and country using the <code>LANG</code> input variable.<br/>Rather than assume that users would want the article that gets served to their country (which is what you get when you omit that information from the URL), I made users specify it. My bet is that <code>en-us</code> will always be the first article updated, so I wanted users to be able to specify that. Also, if they wanted to track more than one language-country combination, they could override it more than once and track both versions this way. Because of this, I added the language-country code to the filename of the page we saved. I made <code>en-us</code> the default, which will meet most user‚Äôs needs.</li>
<li>In order to avoid redundant copying of the file when it hasn‚Äôt changed, I added the <code>StopProcessingIf</code> processor.<br/>This is, admittedly, a minor efficiency in this case, since the file is so small, but I do this in all my <code>.ds</code> recipes and decided to be consistent.</li>
</ol>
<p>Because there was no precedent for this, I did question whether I should invent a new recipe type or even whether I should split the recipe such that the copying occurred in a separate child recipe. I determined that most people who would use the recipe would want to archive a copy of the article and that there was no post-processing of the file (save for the filename), so I kept it all as a <code>.download</code> recipe. For those who didn‚Äôt want to retain an archived copy, I carefully placed an <code>EndOfCheckPhase</code> processor just before copying the file so that running the recipe using <code>autopkg run --check</code> would avoid the copy entirely.</p>
<h3 id="yesbut">Yes, but‚Ä¶</h3>
<p>I received very positive feedback on Twitter after I announced the existence of this recipe. So it was all the more painful to have to walk this back a bit a few days later. You see, a scheduled run of my recipe reported a change in HT208020 a few days later, even though the Published Date remained the same. I confirmed that the content you would see in a browser had not changed. So what did? Items in the page header. Things like the page‚Äôs ‚ÄúHelpful‚Äù rating, the expiry date for the cookie that Apple leaves behind, and any updates Apple may have made to their Javascript code in the interim. <em>Sigh.</em></p>
<p>The most robust solution would be to compare only the content inside the body, perhaps even completely stripped of markup. That would require a custom processor that would (1) use <code>URLDownloader</code> or similar code to grab the current version, (2) if it reported that there was a new version, perform a comparison of the body contents with a past version that was stored somewhere in the cache, and (3) report back via the <code>download_changed</code> variable whether the Article‚Äôs content had truly changed or not. This is not a level of complexity that interests me right now. If someone else wishes to write that processor and maintain it, I‚Äôll happily update my recipe to use your processor‚Äîor you could just <strike>steal</strike> learn from my recipe and write your own to work with your processor; I‚Äôm OK either way.</p>
<p>The good news is that the recipe as written will simply overwrite the Article, since the date+timestamp for Published Date hasn‚Äôt changed. So if you are being notified when the recipe downloads a ‚Äúnew‚Äù copy (e.g., using <a href="https://github.com/lindegroup/autopkgr" target="_blank">AutoPkgr</a>), you can just check your directory of archived articles; if there isn‚Äôt an additional file with a different date in the filename in that directory, the content wasn‚Äôt updated. At this point, I‚Äôm willing to live with that limitation.</p>
<h3>A More General Recipe</h3>
<p>Along with this blog post, I‚Äôm also releasing a new recipe, <a href="https://github.com/autopkg/jazzace-recipes/blob/master/JazzAce/webpage.download.recipe" target="_blank">webpages.download</a>, that is generalized for any web page. Based on what you‚Äôve read above, you‚Äôll understand why it will work best with static web pages where the header or injected scripts won‚Äôt change. The site you‚Äôre visting now is one where it will work well, as it is developed using <a href="https://jekyllrb.com" target="_blank">Jekyll</a> (a static site generator) on <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>. The default Input values should work as a faux-RSS feed for my blog posts, but you are of course welcome to override them with pages you want to track. I did some text massaging of the date in that one using a shared processor, so you‚Äôll need to add Elliot Jordan‚Äôs <a href="https://github.com/autopkg/homebysix-recipes" target="_blank">homebysix-recipes</a> to your RecipesRepo in addition to mine (jazzace-recipes) in order to run it.</p>
<h3>Upcoming Presentation</h3>
<p>If you want to learn more about AutoPkg, especially if you have dabbled with AutoPkgr but haven‚Äôt delved into writing recipes or using AutoPkg at the command line, I‚Äôll be <a href="https://psumac2018.sched.com/event/EgHl/autopkg-level-up" target="_blank">giving a presentation</a> at the <a href="https://macadmins.psu.edu" target="_blank">2018 Mac Admins Conference at Penn State</a> on just that topic. This is the conference where I found my professional peer group; I cannot recommend it highly enough. Please approach me and say, ‚ÄúHi,‚Äù if you are there.</p>
<p><cite>Note: The AppleSupportArticle.download recipe has been updated (re: date format) and a second recipe has been added that you may prefer. I wrote <a href="/2018/09/19/applesupportarticledatetitle.html" target="_blank">an additional blog post about those changes on 2018-09-19.</a></cite></p>
<hr />
<p id="foot1">[1] In developing the AppleSupportArticle AutoPkg recipe, I noticed that the Published Date for the non-English language versions of the article was 15 days later. Armin Briegel surmised to me that all the versions were updated publicly on the same date (May 25) and I tend to agree. Taking three days for someone to find the change makes more sense than 18. <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] It is common to reference relative paths in the markup on a web site. Since the downloaded page ‚Äî the equivalent of manually doing a <code>Save As‚Ä¶ > Page Source</code> ‚Äî does not have the same resources locally in the same relative locations, such as CSS (stylesheets) and images, those will not be loaded, affecting appearance. <a href="#ref2">[Return to main text]</a></p>
<p id="foot3">[3] For those of you who don‚Äôt encounter XML/HTML entities very often, <code>&amp;lt;</code> stands for a less than symbol and <code>&amp;gt;</code> for greater than; we can‚Äôt use the proper character because they have a special meaning in XML, so this is how you ‚Äúescape‚Äù those characters. <a href="#ref3">[Return to main text]</a></p>
