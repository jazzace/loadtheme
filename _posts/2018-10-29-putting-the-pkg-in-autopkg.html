---
layout: post
title: üì¶ Putting the Pkg in AutoPkg
---
<p>For many people, <cite>AutoPkg</cite> could have easily been named <cite>AutoUpdate</cite> in recognition of its unparalleled ability to fetch updates for the apps you deploy. Yes, it can create packages as well, but perhaps the only packages you have seen being built by AutoPkg are those that are a simple wrapper around a downloaded app.<a href="#foot1" id="ref1"><sup>[1]</sup></a> With the AppPkgCreator processor (introduced with AutoPkg 1.0.0), creating such a recipe is even simpler than before.</p>
<p>But AutoPkg has always been about automating ‚Äúthe tasks one would normally perform manually to prepare third-party software for mass deployment.‚Äù<a href="#foot2" id="ref2"><sup>[2]</sup></a> What if you need to modify something or add to it before deploying? If it is the same process every time, why not have AutoPkg do it for you? Here are three examples of recipes that do just that, explained in detail.</p>
<h3>FirefoxAutoconfig</h3>
<p>The main model I used when learning about AutoPkg‚Äôs ability to build custom packages was the <a href="https://github.com/autopkg/gregneagle-recipes/blob/master/Mozilla/FirefoxAutoconfig.pkg.recipe" target="_blank">FirefoxAutoconfig.pkg recipe written by Greg Neagle</a>. Firefox allows administrators to configure their deployment of Firefox, usually to preset or lock certain preferences. That ability can be very useful in certain deployments (in my case, a Lab deployment where we want to control updates, block password saving, and the like). While we will soon be able to establish such settings via a configuration profile,<a href="#foot3" id="ref3"><sup>[3]</sup></a> the only method supported until then requires making a configuration file and stuffing it in the application bundle. Historically, the most common tool used to create a supported configuration file has been <a href="https://mike.kaply.com/cck2/" target="_blank">the CCK (later, the CCK2) Firefox extension</a> written by Mike Kaply. Deploying the configuration payload manually could be tedious; that‚Äôs where Greg‚Äôs FirefoxAutoconfig.pkg recipe comes in. It downloads a copy of Firefox, copies the app from the disk image to the cache, adds the autoconfig file (generated by CCK2) to the place within the application bundle that Firefox requires, and then creates an installer package of this modified app. All the recipe user needs to do is place the <code>autoconfig.zip</code> file they generated with CCK2 in the same directory as the recipe (usually, the RecipeOverrides directory within your AutoPkg setup); AutoPkg will do the rest. You can see how having a Firefox installer always available pre-configured with your settings could save a lot of work for an admin, especially considering Firefox‚Äôs regular release cycle. Let‚Äôs take a closer look at the recipe.</p>
<p>The recipe runs the Firefox.download recipe from the main AutoPkg recipes repo and then adds the following processor steps:</p>
<ol>
    <li>AppDmgVersioner [grabs the version number of the downloaded app for later use]</li>
    <li>PkgRootCreator [creates a place in the cache where the files being deployed will be added]</li>
    <li>Copier [copies the Firefox app from the disk image into the Applications folder inside the package root just created]</li>
    <li>Unarchiver [copies the configuration files inside the <code>autoconfig.zip</code> archive to where Firefox requires them inside the app bundle]</li>
    <li>PkgCreator [creates a package based on the content in the package root, named with a custom name and the app‚Äôs version number (acquired earlier)]</li>
</ol>
<p>There are a few interesting details to consider here.</p>
<p>With PkgRootCreator, a directory for the installer payload is created inside the cache in a folder named with the value of the NAME input key; this is the normal convention. When you create the package root, you normally create all the directories you need for the payload you are going to deliver, since the package needs to mimic the system directory layout. Thus, the recipe creates an Applications directory at the root of the package with the same read-write-execute permissions (expressed as the octal number 0775) as you would usually see on that folder. You could create additional directories by specifying more key+string pairs within the <code>pkgdirs</code> dictionary.</p>
<p>The use of Unarchiver is both unusual and creative. In many cases, you would use a Copier processor here, but since the contents of the <code>autoconfig.zip</code> archive (once expanded) is what we need placed inside <code>Contents/Resources</code> within the application bundle, Greg chose to unarchive directly to that specific destination.</p>
<p>Finally, PkgCreator contains the instructions for AutoPkg to use when building the package (you can find out more about what each of the settings means <a href="https://github.com/autopkg/autopkg/blob/9aec378fb84dbe031f601131d1d781b94df7ac3f/Code/autopkgserver/autopkgserver#L36-L71" target="_blank">in the documentation found within the source code of <code>autopkgserver</code></a>). The most interesting setting for us is the <code>chown</code> section. In general, any directory you created with the PkgRootCreator processor should have owner and group set within this processor.<a href="#foot4" id="ref4"><sup>[4]</sup></a> In this case, <code>root</code> and <code>admin</code> are the normal owner and group for the Applications folder, so they have been specified here.</p>
<p>Just a short sidebar on Firefox here: Mozilla created a <a href="https://support.mozilla.org/en-US/kb/customizing-firefox-using-policiesjson" target="_blank">new JSON-based configuration method</a> that works with Firefox 60 or later (and is supported cross-platform). Neil Martin adapted Greg Neagle‚Äôs recipe to support this new method. If you examine the recipe (<a href="https://github.com/autopkg/neilmartin83-recipes/blob/master/Mozilla/FirefoxPolicies.pkg.recipe" target="_blank">FirefoxPolicies.pkg in the neilmartin83-recipes repo</a>), the only significant difference is the use of the Copier processor in the fourth processor step. It also requires the user to place the payload to add to Firefox within a particular location in your AutoPkg cache.</p>
<h3>VueScanLicenced</h3>
<p>The reason I wrote the <a href="https://github.com/autopkg/jazzace-recipes/blob/master/Hamrick/VueScanLicenced.pkg.recipe" target="_blank">VueScanLicenced.pkg recipe</a> is not because I need to mass deploy VueScan‚Äîcurrently, I‚Äôm deploying it on one Mac. It‚Äôs because by doing so I can eliminate a manual process that is not going to change any time soon (due to the vendor‚Äôs free update policy for the Pro licence). Writing the recipe functions as both automation and documentation, as you will see in a moment.</p>
<p>Just as with the FirefoxAutoconfig.pkg recipe we just looked at, this recipe uses an existing download recipe for VueScan as the parent. It then adds the following processor steps, which are also very similar:</p>
<ol>
    <li>AppDmgVersioner [grabs the version number of the downloaded app for later use]</li>
    <li>PkgRootCreator [creates a place in the cache where the files being deployed will be added, including the directories needed for the files]</li>
    <li>Copier [copies the VueScan app from the disk image into the Applications folder inside the package root just created]</li>
    <li>Copier [copies the VueScan licence information file from the user-specified location on the local disk to the place that VueScan requires it]</li>
    <li>PkgCreator [creates a package based on the content in the package root, named with a custom name and the app‚Äôs version number (acquired earlier)]</li>
</ol>
<p>The main difference between this recipe and FirefoxAutoconfig is that we create three directories when creating the package root, since we will have a file not just in /Applications, but also in /Users/Shared (we have to create /Users before we can create /Users/Shared). As I mentioned earlier, this is done by simply listing key+string pairs (path plus permissions) in the <code>pkgdirs</code> dictionary. This also means that when we build the package, we need to set the ownership for all three directories, which is done using an array in the PkgCreator processor step (pkg_request > chown > dict for each directory). Finally, we use the Copier processor to place the licence information file in the location required for VueScan to recognize it. In this case, I‚Äôve documented in the recipe Description how to generate the necessary file, the easiest way being to temporarily authorize VueScan on the Mac (or VM) that runs AutoPkg such that the licence information file will be placed in the default location. But I have also documented what the contents of that licence file are, since it is a simple text file that you can construct and locate anywhere on the local system. Since the Copier processor requires that we specify the full path for the copied text file, this allows us the flexibility to let the user do this. In the FirefoxAutoconfig example, that recipe could just as easily been written to require that the user specify the path to the <code>autoconfig.zip</code> file as an input variable, but is probably cleaner as it was written. In the case of my recipe, since the filename of the licence information file that VueScan requires starts with a dot (and thus makes the file invisible in the Finder by default), I decided to allow the recipe user to make that a visible file if they wished, hence the RC_FILE input key. The (second) Copier processor simply renames the file to the required value when placing it in /Users/Shared within the package root.</p>
<p>To be clear, because this is a process I only need to do once a year, I could have suffered along doing it manually or I could have used a dedicated package creation tool (e.g., <a href="http://s.sudre.free.fr/Software/Packages/about.html" target="_blank">WhiteBox Packages</a>, <a href="https://www.jamf.com/products/jamf-composer/" target="_blank">Jamf Composer</a>, <a href="https://github.com/munki/munki-pkg" target="_blank">munkipkg</a>, <a href="https://github.com/unixorn/luggage" target="_blank">The Luggage</a>) or even the <code>pkgbuild</code> tool in macOS (which all the other tools leverage to do their work). But since I was comfortable with how AutoPkg works, I took advantage of its ability to build arbitrary packages to make my future deployments easier.</p>
<h3>AbletonLive</h3>
<p>Recently, I needed to deploy Ableton Live 10 Lite. Conveniently, <a href="https://github.com/autopkg/timsutton-recipes/blob/master/Ableton/AbletonLive9.download.recipe" target="_blank">Tim Sutton had already written a download recipe for version 9</a> that could easily be adapted for the current version. But I noticed that the download recipe did not include code signature verification. So since Tim has changed jobs since he wrote that recipe and is unlikely to update (or want to maintain) it, I decided I would adapt his download recipe for version 10 and <a href="https://github.com/autopkg/jazzace-recipes/tree/master/Ableton" target="_blank">release it in my repo</a>, adding further child recipes to support my deployment needs. Let‚Äôs examine the <a href="https://github.com/autopkg/jazzace-recipes/blob/master/Ableton/AbletonLive.download.recipe" target="_blank">download</a> and <a href="https://github.com/autopkg/jazzace-recipes/blob/master/Ableton/AbletonLive.pkg.recipe" target="_blank">pkg</a> recipes in my repo.</p>
<p>Here are the processor steps I use to create the package installer for Live:</p>
<ol>
    <li>URLTextSearcher [grabs the latest version number from a web page on the Ableton web site]</li>
    <li>URLDownloader [downloads the latest installer]</li>
    <li>EndOfCheckPhase [allows anyone running the recipe with the <code>--check</code> option to gracefully exit]</li>
    <li>CodeSignatureVerifier [verifies that the app downloaded is codesigned]</li>
    <li>FileFinder [grabs the name of the app from the disk image for use in subsequent steps]</li>
    <li>Copier [copies the app from the disk image to a location in the cache]</li>
    <li>PathDeleter [eliminates the SoundCloud extension from the app bundle ‚Äì more on this in a moment]</li>
    <li>AppPkgCreator [wraps the edited app in a pkg installer]</li>
    <li>StopProcessingIf [‚Ä¶we didn't need to build a new package]</li>
    <li>PathDeleter [delete extra copies of the (rather large) app created as a part of the automation]</li>
</ol>
<p>Let me highlight some of the details, both of Tim‚Äôs original recipe and my extensions thereof.</p>
<p>Ableton provides a page on their web site that lists the latest minor version of their two most recent versions. They also use a very uniform download URL scheme, such that, if you know the version number, you can determine the URL for the download. So Tim‚Äôs original recipe leveraged that and grabbed the version number from the web page.<a href="#foot5" id="ref5"><sup>[5]</sup></a> His recipe also gave the user the option to download the 32-bit or 64-bit version. In my update, I eliminated the 32-bit option (since it won‚Äôt be useful for very much longer) and added the ability to specify which major version you wanted. In many ways, I‚Äôm trying to future-proof the recipe, such that when Version 11 is released, you might only need to change your override to make it work.</p>
<p>The FileFinder-Copier-PathDeleter processor sequence was necessary because of an issue with the app bundle. When I simply used AppPkgCreator to create the package, it failed with the following error: <code>
pkgbuild failed with exit code -6: [/BuildRoot/Library/Caches/com.apple.xbs/Sources/Bom/Bom-194.2/FSObject/BOMFSOArchInfo.c:477] file OAuth2Client is corrupt: slice for &lt;cputype 117440512, subtype 50331648&gt; extends beyond length of file. (218168 &gt; 218145)</code></p>
<p>The key in that message is that <code>pkgbuild</code>, the command line tool behind AutoPkg‚Äôs ability to build packages, found a problem building the package. I re-downloaded just in case, and it was not a case of a failed or corrupted download. Because the problem was with pkgbuild, that meant any other tool that would try to build a package from that app (like the ones I mentioned earlier) would have the same problem. In searching the #autopkg channel on the MacAdmins Slack, I saw that Stephen Warneford-Bygrave also had this problem back with Version 9 of Live and found that deleting the SoundCloud extension in the app bundle allowed the package to be built. This is what led to the steps before the AppPkgCreator processor.</p>
<p>The FileFinder processor was new to me. It helped solve a problem caused by the fact that the recipe can download any of the five variants of Live (and in one of two major versions). I want the app that we deploy to have the same name as the one that we downloaded, but the Copier processor requires that you supply the app name for the target; you can‚Äôt just do like you might using <code>cp</code> on the command line. In a recipe that had fewer options, I could have just hard coded the matching value. In this instance, FileFinder can determine that name for me. Since there is only one app in the disk image downloaded, I can use FileFinder to find the app name by specifying a simple <code>*.app</code> globbing match within the disk image; it will return the filename of the app as the variable <code>dmg_found_filename</code>, which I can then use in the Copier processor. Once I‚Äôve got the app copied, I can remove the SoundCloud extension using the PathDeleter processor.</p>
<p>When I make the package installer from the modified app, I simplified things by using the AppPkgCreator processor. More commonly, you would use this processor on an app still contained in a disk image, but it works on any app you can point to, including ones extracted from an archive or already copied from a disk image (like we did in this case).</p>
<p>I would not normally include the last two processor steps, but Ableton Live is close to 2 GB in size, even in the ‚ÄúLite‚Äù edition. The extra copies of the app generated by the recipe (particularly on a non-APFS drive) could start filling your storage quickly. So I chose to ‚Äúclean up after myself‚Äù and delete both the app I copied (and then modified) and the scratch area that AppPkgCreator used to make another copy of the modified app for bundling into the package. The StopProcessingIf processor is the only processor in AutoPkg that is conditional. The reason I used it here is because I chose to be aggressive with what I cleaned up with PathDeleter; when the recipe is run and there is no new package to build, the <code>payload</code> directory is not created, so trying to delete it throws an error. Thus, StopProcessingIf causes this recipe to stop if there is no new package to build.</p>
<p>Long after I finished working on the pkg recipe, I took a close look at the <a href="https://github.com/autopkg/moofit-recipes/blob/master/Ableton/AbletonLive9.pkg.recipe" target="_blank">MoofIT pkg recipe for Live 9</a>. This takes an approach more like the first recipe we looked at, using the traditional package-building processors. It has the benefit of not using as much storage space (hence the lack of cleanup steps) but has to do the work that AppPkgCreator provides for free. You can make good arguments for either approach.</p>
<h3>More Reading/Watching</h3>
<p>If you decide that you want to learn more about using AutoPkg as a general purpose packaging tool, Greg Neagle wrote a 
<a href="https://managingosx.wordpress.com/2015/07/30/using-autopkg-for-general-purpose-packaging/" target="_blank">blog post on the topic</a>, complete with <a href="https://github.com/gregneagle/autopkg-packaging-demo" target="_blank">a few examples in a GitHub repo of his</a>. Those examples are more of the type where you already have the files you need (because you probably created them) and want to use AutoPkg to turn them into an installer.</p>
<p>Also, since two of our examples messed with an application bundle, I feel it is my Mac Admins duty to remind you that you can do bad things with AutoPkg. Elliot Jordan has done a few talks on this very topic, most of which have been recorded. I recommend you check out his presentation from the 2017 Mac Admins Conference at Penn State (<a href="http://macadmins.psu.edu/files/2017/07/psumac2017-195-How-Not-To-Do-Bad-Things-With-AutoPkg-1w0jwjx.pdf" target="_blank">slides</a> or <a href="https://youtu.be/LnvQmLcDF8w" target="_blank">video</a>), as it includes information about the trust verification features added in AutoPkg 1.0.0.</p>
<p>I hope the examples I provided in this blog post help you leverage more of the power of AutoPkg to automate things you would otherwise need to do manually.</p>
<hr />
<p><cite>Note 1: An earlier version of this post suggested there was only one file inside the <code>autoconfig.zip</code> archive required for the FirefoxAutoconfig recipe. There are multiple files and directories. Note 2: A few minor cleanups were made for grammatical and formatting reasons on 2018-11-03.</cite></p>
<hr />
<p id="foot1">[1] If you are a Munki user, you may not need to have it create a package for you, since Munki knows how to directly install drag-and-drop apps, configuration profiles, etc. <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] Source: <a href="https://github.com/autopkg/autopkg/blob/master/ReadMe.md" target="_blank">AutoPkg ReadMe.</a> <a href="#ref2">[Return to main text]</a></p>
<p id="foot3">[3] Support is scheduled for <a href="https://www.mozilla.org/en-US/firefox/64.0beta/releasenotes/" target="_blank">Version 64 (regular release)</a>‚Äîin beta as I write this‚Äîand Version 68 Extended Support Release (ESR) in July 2019. <a href="#ref3">[Return to main text]</a></p>
<p id="foot4">[4] It is also possible to set the read-write-execute permissions at this point, but since you set them when using PkgRootCreator, it will maintain the existing permissions if you don‚Äôt specify anything here. <a href="#ref4">[Return to main text]</a></p>
<p id="foot5">[5] Note that Tim‚Äôs regular expression leveraged Python‚Äôs ability to assign a value to a variable based on a part of a regular expression. I discovered this first in another recipe and have been using it in my recipe writing ever since. In Python, the form is <code>(?P&lt;variable_name&gt;what-you-want-to-capture)</code> but since a recipe is an XML file, we need to ‚Äúescape‚Äù the angle brackets, since they have a special meaning in XML. Hence, we use <code>&amp;lt;</code> and <code>&amp;gt;</code> in the recipe. In this instance, the version number is assigned to <code>version</code>, which we can then use in subsequent steps for any processor that wants a value for <code>version</code> or we can insert <code>%version%</code> in any string where we want that value. In this particular recipe, I used it in a lot of places. I also reference this technique in <a href="https://maclabs.jazzace.ca/2018/06/17/checking-web-pages-with-autopkg.html" target="_blank">an earlier blog post</a>. <a href="#ref5">[Return to main text]</a></p>

