---
layout: post
title: üì¶ Feeding Outset 2ÔºöOverride Boogaloo
description: How to add a postinstall script to the Outset payload package we built in the previous post so that the payload will be processed for all users if it is an updated payload
---
<p><a href="/2022/12/30/feeding-outset-1.html" target="_blank">In my previous blog post,</a> I described my AutoPkg recipe that builds a package for a script you might want to run via Outset. For me, I want to deliver most of my scripts to Outset‚Äôs login-once folder, since I use Outset to set some initial user settings in my computer labs. But since I only delete user accounts once every four months (or when the internal drive fills, whichever comes first), I can get into the situation where I want to push out an updated version of a script that some users have already run once (for example, to set up the default dock). Outset normally tracks whether or not an item at a particular path has been processed, not whether that item has changed, so how can I force an updated login-once item to be processed? The answer is what Outset calls a Login-Once Override ‚Äî and yes, we can have AutoPkg automate that too.</p>
<h3>Outset Overrides</h3>
<p>Outset tracks when it successfully runs a login-once (or login-privileged-once) item in its user preferences<a href="#foot1" id="ref1"><sup>[1]</sup></a> (<code>~/Library/Preferences/com.github.outset.once.plist</code>). For example:</p>
<pre>&lt;key&gt;/usr/local/outset/login-once/setDock.sh&lt;/key&gt;
&lt;date&gt;2023-01-02T17:47:19Z&lt;/date&gt;
</pre>
<p>Each time a user logs in, Outset checks those user preferences. If a particular login-[privileged-]once item has already been processed for that user, it is skipped. However, you can add a Login-Once Override via a shell command to indicate that the item has changed and should be treated like a new item. The command looks something like this (using our previous example):</p>
<pre>/usr/local/outset/outset --add-override /usr/local/outset/login-once/setDock.sh</pre>
<p>That adds a timestamp for that item to the global Outset preferences ( <code>/usr/local/outset/share/com.chilcote.outset.plist</code>) using the same key/date pair format as in the user preferences. On subsequent user logins, Outset will compare the override timestamp for each item overridden with the last run timestamp for that particular user. If the override timestamp is newer, then the item will be processed again. (A more detailed explanation of Login-Once Overrides is <a href="https://github.com/chilcote/outset/wiki/ScriptOverrides" target="_blank">available in the Outset wiki</a>.)</p>
<h3>Automating the Override</h3>
<p>Your management system may provide you with a way to execute that shell command at the same time as you deploy the updated item to Outset, but the Outset wiki helpfully suggests another method: creating a postinstall script with the command and adding it to the package that delivers the item to Outset. This is a perfect task to automate. Since I already have an existing .pkg recipe that delivers the payload for Outset, I can add a couple of steps to it to incorporate a postinstall script. I‚Äôve called the resulting recipe <a href="https://github.com/autopkg/jazzace-recipes/blob/master/JazzAce/OutsetLoginOverridePkgReqd.pkg.recipe" target="_blank">OutsetLoginOverridePkgReqd.pkg</a>. Let me describe what I added.</p>
<h4>Creating the scripts Directory</h4>
<p>The <code>PkgRootCreator</code> processor creates the directory structure needed for your payload. However, you generally do not want the postinstall script to be in the same directory as the payload. The AutoPkg convention is to create a scripts folder at the same level in your AutoPkg cache as the payload. Invoking the <code>PkgRootCreator</code> a second time is the best way to accomplish this. So in my updated recipe, I do that just before invoking the <code>PkgRootCreator</code> for the payload itself.<a href="#foot2" id="ref2"><sup>[2]</sup></a>.</p>
<h4>Creating the Login-Once Override</h4>
<p>The other step to add for this recipe is to create the postinstall script. The <code>FileCreator</code> processor is perfect for this. You specify the text you want to include in the postinstall script using the <code>file_content</code> argument, which in this case is a shell script. Note that you can have a script that spans multiple lines, so it can be as simple or as complex as needed. In this case, I have three lines: a shebang, a documenting comment, and the Outset <code>--add-override</code> command. The <code>FileCreator</code> processor supports AutoPkg variable substitution, so that is how I pointed Outset to the item I am overriding:</p>
<pre>/usr/local/outset/outset --add-override "/usr/local/outset/%ACTION_TYPE%/%name_with_ext%"</pre>
<p>Using the earlier example, that would show up in the postinstall script as:</p>
<pre>/usr/local/outset/outset --add-override "/usr/local/outset/login-once/setDock.sh"</pre>
<p>I make certain the script is set to be executable by setting a <code>file_mode</code> of 0755 in the <code>Arguments</code>.</p>
<p>For the <code>PkgCreator</code> processor to add the postinstall script, I need to add the location of the script to the <code>pkg_request</code> dictionary using the <code>scripts</code> key.</p>
<pre>&lt;key&gt;scripts&lt;/key&gt;
&lt;string&gt;%RECIPE_CACHE_DIR%/scripts&lt;/string&gt;</pre>
<p>Finally, I added the scripts folder to the cleanup I do with <code>PathDeleter</code> after the package is built. We now have a recipe to create a package that delivers the Outset payload we want and triggers a Login-Once Override for it.</p>
<p>All the other steps from my <a href="/2022/12/30/feeding-outset-1.html" target="_blank">previous post</a> ‚Äî creating the recipe override, adjusting the Input variables, optionally adding a <code>PKG</code> variable to the Input variables to point to a particular payload file ‚Äî apply equally to this variation of the recipe.</p>
<h3>Adding it to your Management System</h3>
<p>The main reason I went down the path of creating a package for my Outset items was because Jamf Pro doesn‚Äôt natively support dropping a file in an arbitrary location on the managed system, but this method using AutoPkg creates a package that <em>any</em> management system can use. If your management system <em>is</em> Jamf Pro, then you probably already know that the JamfUploader family of AutoPkg processors can get this package into Jamf Pro, create/update a policy that deploys it, and even flush the log so that the payload will be delivered on next login. Since I describe how to build such recipes in detail in the <a href="https://grahamrpugh.com/2021/10/21/jnuc-presentation-jamfuploader-session.html" target="_blank">recent</a> <a href="/2022/07/14/jamfuploader.html" target="_blank">presentations</a> Graham Pugh and I have done, I won‚Äôt repeat those instructions here, but I have added <a href="https://github.com/autopkg/jazzace-recipes/tree/master/JazzAce" target="_blank">the .jamf recipes I wrote for this purpose to my repo</a> for you to use or peruse.</p>
<p>Adding a Login-Once Override is another great way to use Outset and automating the creation of a package that has a variable postinstall script is another one of the many ways AutoPkg can automate your workflows.</p>
<hr/>
<p id="foot1">[1] Or do we call them ‚Äùsettings‚Äú now? <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] The <code>PkgRootCreator</code> processor establishes the value (path) for <code>pkgroot</code>, which is used by <code>PkgCreator</code>. In my recipe, I chose to create the paths to the payload second so that the <code>pkgroot</code> variable is set to what I want when I create the package. But I could also have set <code>pkgroot</code> to <code>%RECIPE_CACHE_DIR%/payload</code> in the <code>pkg_request</code> dictionary and not worried about which order I created the payload and scripts directory structures. <a href="#ref2">[Return to main text]</a></p>