---
layout: post
title: ðŸ“¦ Generic App-Packaging Recipes for AutoPkg
---
<p>One of the MacAdmin-friendly features I love about the app <a href="http://s.sudre.free.fr/Software/Packages/about.html" target="_blank">Packages by StÃ©phane Sudre</a> is Quick Build: the ability to build a package installer for a self-contained app by simply dragging-and-dropping that app onto the Packages app. If youâ€™re using a software distribution system that wants package installers, this can be a great time saver. But if youâ€™re reading this, youâ€™re probably an AutoPkg user and have automated creating package installers using app-specific recipes (either your own or those written by others). Still, sometimes you need to build such a package once or twice, so writing a recipe doesnâ€™t actually save you time.</p>
<p>In doing the background work for my previous post on <a href="/2018/11/12/running-autopkg-recipe-with-pkg-option.html" target="_blank">running a recipe with the <code>--pkg</code> option</a>, I wondered if AutoPkg could package up any app on demand like Packages does. It turns out that it can. Hereâ€™s how.</p>
<h3>Package(Dmg)App</h3>
<p>Iâ€™ve added two new recipes to my repo: PackageApp.pkg and PackageDmgApp.pkg. The whole point of them is to replicate the Packages Quick Build feature. The two recipes differ in only one respect: PackageApp expects you to supply the path to the app bundle whereas PackageDmgApp expects the path to the disk image that contains the app.</p>
<p>If you have trust verification turned on (and you should), youâ€™ll want to create an override for each of these recipes. Since neither recipe uses any input variables, you wonâ€™t need to edit the overrides. Of course, you will need my jazzace-recipes repo downloaded to your local RecipesRepo.</p>
<p>Hereâ€™s probably the simplest way to use the PackageApp recipe:</p>
<ol><li>In Terminal, type <code>autopkg run PackageApp.pkg --pkg </code> (making certain there is a space after --pkg).</li>
<li>Locate the app you want to bundle up into a package installer in the Finder and drag-and-drop it onto the Terminal window. (Terminal will enter the path to the app automatically.)</li>
<li>Press Return.</li>
</ol>
<p>The package will be built and placed in your AutoPkg Cache under the identifier of the recipe (e.g., local.pkg.packageapp if you created an override). Because you are doing this on demand, the recipe asks AutoPkg to build the package every time, even if there seems to be an identical package in the cache.</p>
<p>The workflow for the PackageDmgApp.pkg recipe is the same, except you drop a disk image (with an app inside) on the Terminal windowâ€”AutoPkg will automatically mount the disk, extract the app, and then dismount it. This is probably the best use case, since Packages requires that you drag the <em>app</em> onto it (which means you have to manually mount the disk image first).</p>
<h3>Output Differences Between Packages and AutoPkg</h3>
<p>These recipes rely on the AppPkgCreator processor introduced in AutoPkg 1.0.0. At first glance, it appears that the packages generated by that processor are the same as those generated by the Packages app. But there are a few minor differences in the metadata that may interest Mac Admins:</p>
<table>
	<thead>
	<tr> <th>&nbsp;</th>	<th>Packages app</th>	<th>AppPkgCreator (AutoPkg)</th> </tr>
	</thead>
	<tbody>
	<tr> <th>PackageFileName</th>	<td>AppName.pkg</td>	<td>AppName-version.pkg</td> </tr>
	<tr> <th>PackageIdentifier</th>	<td>company.qb-pkg.AppName<br/>e.g., org.mozilla.qb-pkg.firefox</td>	<td>company.AppName<br/>e.g., org.mozilla.firefox</td> </tr>
	<tr> <th>PackageVersion</th>	<td>1.0 or Bundle Version (preference setting)</td>	<td>CFBundleShortVersionString</td> </tr>
	<tr> <th>InstallPrefixPath</th>	<td><cite>blank</cite></td>	<td>/</td> </tr>
	</tbody>
</table>
<p>These are the values you will find in the installer receipt (<code>/var/db/receipts</code>)â€”the values in the left column are the keys in the related plist stored there. The actual payload is the same; neither method messes with the app bundle.</p>
<h3>Limitations</h3>
<p>The limitations of this ad hoc AutoPkg packaging method are not numerous but are worth noting:</p>
<ul><li>You canâ€™t use AutoPkgâ€™s Code Signature Verification with this method because the signature will vary. Thus, the source verification is left to the Admin.</li>
<li>You cannot sign your newly-created installer package with a Developer ID certificate using these recipes. (Packages can do this, either with a pre-loaded certificate or by prompting you for one each time you build a package.) If you do wish to do this with AutoPkg, <a href="https://derflounder.wordpress.com/2017/11/10/adding-installer-package-code-signing-to-autopkg-workflows/" target="_blank">Rich Trouton has documented the way to sign installer packages using AutoPkg and a custom processor from Paul Suh</a>. You could either rewrite my recipes or add a child recipe with the PkgSigner processor.</li>
<li>Certain apps (mostly from Apple) simply reject being packaged this way. (Packages seems to trip over the same apps.) If there are Mac App Store apps you want to package and you are not managing those apps using Apple School/Business Managerâ€™s Volume Store (a.k.a. VPP), you may want to check out <a href="https://github.com/autopkg/nmcspadden-recipes/tree/master/AppStoreApp" target="_blank">Nick McSpaddenâ€™s AppStoreApp recipes</a>â€”they operate a little differently than other AutoPkg apps, so <a href="https://github.com/autopkg/nmcspadden-recipes" target="_blank">read the documentation</a> before using them.</li>
</ul>
<h3>When It Absolutely, Positivelyâ€¦</h3>
<p>Most of the time, youâ€™ll want to write a proper pkg recipe so that you can take advantage of the extra security you get from Code Signature Verification. But when you have something from a trusted source that you need to get packaged <em>now</em>, AutoPkg can do the job for you using these new recipes.</p>
