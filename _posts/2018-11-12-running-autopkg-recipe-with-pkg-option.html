---
layout: post
title: üì¶ Running an AutoPkg Recipe with the --pkg Option
---
<p>AutoPkg offers an option when you run a recipe from the command line that is mentioned exactly once in the Wiki: the <code>--pkg</code> (or <code>-p</code>) option.<a href="#foot1" id="ref1"><sup>[1]</sup></a> Yet that option that can be very useful for recipe authors and users alike. This post is the missing documentation for that option.</p>
<h3>What Does It Do? (TL;DR)</h3>
<p>The <code>--pkg</code> option allows you to direct AutoPkg to use a package or disk image that you have on hand (which you probably manually downloaded) instead of downloading whatever the URLDownloader processor in your recipe would normally retrieve. URLDownloader will treat the supplied item as an updated version (i.e. it sets the output variable <code>download_changed</code> to <code>True</code>). If your recipe chain doesn‚Äôt use URLDownloader, your recipe can still access the path to the download using variable substitution (i.e. <code>%PKG%</code>).</p>
<h3>Usage</h3>
<p>The syntax is:</p>
<pre>
autopkg run --pkg /path/to/pkg_dmg_or_archive recipename.recipetype
</pre>
<p>or</p>
<pre>
autopkg run recipename.recipetype --pkg /path/to/pkg_dmg_or_archive
</pre>
<p>You may use <code>-p</code> instead of <code>--pkg</code>. You may only use this option when running a single recipe (not a list or multiple recipes).</p>
<h3>Why Would You Use It?</h3>
<p>There are three main reasons to use the <code>--pkg</code> option when running an AutoPkg recipe:</p>
<ul><li>You have access to a version of the software that is newer than the related AutoPkg recipe knows about;</li>
<li>You can‚Äôt automate the download of the software or haven‚Äôt yet done the work to make that happen; and</li>
<li>You are developing a recipe and do not wish to redundantly download the software during testing.</li>
</ul>
<p>Let‚Äôs address each one of these in order.</p>
<h4>Newer Version Available</h4>
<p>‚ÄúWhy hasn‚Äôt AutoPkg found the latest version? I can see it on the vendor‚Äôs web site!‚Äù This is probably the most common usage of the <code>--pkg</code> option‚Äîit‚Äôs even described in the <a href="https://github.com/autopkg/autopkg/wiki/FAQ#everyone-says-a-new-version-of-application-x-was-released-but-autopkg-doesnt-pick-it-up-why" target="_blank">AutoPkg FAQ</a>. When the vendor uses more than one mechanism to make new software available, sometimes these are not updated simultaneously. For example, there might be a new version available for download on their web site but their Sparkle feed hasn‚Äôt been updated yet, and the AutoPkg recipe uses the Sparkle feed to determine the current version. Or perhaps you have been provided with a beta version to help fix a bug and you would like to get that out to your testing group using the recipes that feed your software distribution system (e.g., Munki). Whatever the reason, you can manually download the item in the format that the recipe would normally expect (e.g., dmg, pkg, zip) and specify that path with the <code>--pkg</code> option. For example, MuseScore is provided as an app wrapped in a disk image. If I‚Äôve downloaded the latest version of MuseScore to my Downloads folder, and I want to run the <a href="https://github.com/autopkg/jazzace-recipes/tree/master/MuseScore" target="_blank">pkg recipe for it</a>, I would use the following command:</p>
<pre>
autopkg run MuseScore.pkg --pkg ~/Downloads/MuseScore-2.3.2.dmg
</pre>
<p>AutoPkg will follow all the steps of the recipe, including code signature verification and possibly building a package, but when it gets to the URLDownloader processor, it will skip downloading and will return values as if the item specified by <code>--pkg</code> was just downloaded as a new item.</p>
<h4>PackageRequired</h4>
<p>Sometimes, you just can‚Äôt automate a particular download. Common reasons are: the vendor requires that you provide login credentials to obtain the software, there are too many redirects by the web site for AutoPkg to handle, the site‚Äôs Terms of Service do not allow automated downloads, and the recipe author (probably you) hasn‚Äôt figured out how to automate the download but still wants to use the other features of AutoPkg (like building a package installer or putting the software into your distribution system). Sometimes, you <em>can</em> automate a download, but the product is updated so infrequently, it‚Äôs not worth the effort. Regardless of your reason, the <code>--pkg</code> option works well in this case, in partnership with the PackageRequired processor.</p>
<p>PackageRequired is a processor that has no arguments. The code is so straightforward, you can understand it even if you can‚Äôt write a line of Python (<a href="https://github.com/autopkg/autopkg/blob/master/Code/autopkglib/PackageRequired.py" target="_blank">see for yourself</a>). It simply checks to see if you have used the <code>--pkg</code> option when running the recipe. If the user didn‚Äôt use it (or used it incorrectly), the recipe fails. So the main benefits of the PackageRequired processor are error trapping and self-documentation. Basically, if your recipe chain<a href="#foot2" id="ref2"><sup>[2]</sup></a> doesn‚Äôt use URLDownloader, it probably needs PackageRequired.</p>
<p>Probably the most common product that requires this methodology is Audacity. The Terms of Service of the download provider prohibit automated downloads, so once the community found this out, the download recipe was voluntarily pulled and the other child recipes were changed to support using the <code>--pkg</code> option. The <a href="https://github.com/autopkg/scriptingosx-recipes/blob/master/Audacity/Audacity.pkg.recipe" target="_blank">pkg recipe from Armin Briegel‚Äôs recipe repo</a> is easy to understand. It has three processor steps: PackageRequired, CodeSignatureVerifier, and AppPkgCreator. The recipe confirms that the user supplied something with the <code>--pkg</code> option, verifies the code signature of the app within the disk image, and creates a pkg installer based on the app inside the disk image. Note that the path associated with the <code>--pkg</code> option is assigned to the variable PKG.<a href="#foot3" id="ref3"><sup>[3]</sup></a> So, in both the CodeSignatureVerifier and AppPkgCreator processor steps, the recipe uses <code>%PKG%</code> to specify the path to the downloaded disk image.</p>
<h4>New Recipe Testing</h4>
<p>In the process of developing a new recipe, you may need to download the desired software a number of times, especially if you develop the download recipe first, then child recipes such as pkg, munki, or jss. (Each time you run a different recipe type, AutoPkg will build a new cache for it, thus initiating a new download.) You can avoid the time and bandwidth involved with re-downloading by using the <code>--pkg</code> option. Here‚Äôs a common workflow I use:</p>
<ol><li>Create a download recipe for the software product in the Recipes directory (usually ~/Library/AutoPkg/Recipes).</li>
<li>Run it with trust verification off (or from an override you create) until you are satisfied that it downloads what you are intending. Run it one more time to confirm that it correctly handles the case where there is no new update available.</li>
<li>Create a child recipe (e.g., pkg) in the same recipe directory. Run it with trust verification off (or from an override you create) with the <code>--pkg</code> option; since the download is in the cache from the download recipe you were just testing, you can specify that path as the parameter for the <code>--pkg</code> option. For example:<br/>
<pre>
autopkg run -vv SoftwareTitle.pkg --pkg ~/Library/AutoPkg/Cache/com.github.githubusername.softwaretitle.download/downloads/SoftwareTitle.dmg
</pre>
Once you are satisfied that your child recipe is doing what you are intending, run it one more time to confirm that it correctly handles the case where there is no new update available.</li>
<li>Repeat the previous step for any further child recipes.</li>
</ol>
<p>When I am done that testing, I generally trash all the caches created during testing and run the terminal child recipe without the <code>--pkg</code> option twice, just to confirm that it behaves correctly when it actually has to download something.</p>
<h4>One More (Obscure) Use Case</h4>
<p>For completeness, here is one obscure usage of the same functionality that does not require using <code>--pkg</code> at the command line. The URLDownloader processor has 8 input variables (only <code>url</code> is required). One of these variables is <code>PKG</code>. One could choose to specify a value for PKG, either hard-coded into a recipe you authored as an argument for URLDownloader or as an input variable in a recipe override. The value assigned will be honoured by URLDownloader as the path to the downloaded item. One advantage of this method is that you could include such a recipe in a list of recipes to be run (AutoPkg will throw an error if you use the <code>--pkg</code> option in a <code>run</code> command that includes more than one recipe). The major limitation of this method is that the path to the download (including the filename) needs to be the same every time you run it to make it as efficient as the <code>--pkg</code> option. Having said all this, no publicly-posted recipe uses this ability. So while it does work, the use case appears to be theoretical.</p>
<h3>A Final Learning</h3>
<p>I ended up rewriting one recipe chain I used an example here because of a (beneficial) property of the URLDownloader processor. When you download something with URLDownloader, it returns a number of output variables, including <code>pathname</code>. When you refer to the location of the download in subsequent processors, you want to leverage that variable, including when you specify a path using string substitution (i.e. <code>%pathname%</code>). For example, an <a href="https://github.com/autopkg/jazzace-recipes/blob/2a79921058238ba8a21536697bc1e618f49652db/MuseScore/MuseScore.download.recipe" target="_blank">earlier version of my MuseScore.download recipe</a> told the CodeSignatureVerifier processor that the app to be verified was located at <code>%RECIPE_CACHE_DIR%/downloads/%NAME%.dmg/MuseScore 2.app</code>. That‚Äôs an entirely conventional path for the download, so it worked perfectly well when AutoPkg downloaded the item itself. However, when I used the <code>--pkg</code> option, AutoPkg would refuse to mount the disk image (or would mount a previously downloaded one) because the disk image was not in the expected location. Since URLDownloader correctly sets the value of <code>pathname</code> to the path of the downloaded <em>or</em> supplied item, using <code>%pathname%/MuseScore 2.app</code> works with both downloads and the <code>--pkg</code> run option.
This is another reason why you might want to test the recipes you develop with the <code>--pkg</code> option‚Äîyou can then be assured it will work when used with that option.</p>
<p>I hope that this better explains the utility of the <code>--pkg</code> option for running AutoPkg recipes. If you think some of this information should make its way into the AutoPkg wiki, please provide me direct feedback on the MacAdmins Slack (@jazzace or #autopkg channel).</p>
<p><cite>Updated 2025-04-21 to remove Twitter account reference.</cite></p>
<hr />
<p id="foot1">[1] Reference: <a href="https://github.com/autopkg/autopkg/wiki/FAQ#everyone-says-a-new-version-of-application-x-was-released-but-autopkg-doesnt-pick-it-up-why" target="_blank">AutoPkg Wiki FAQ</a> <a href="#ref1">[Return to main text]</a></p>
<p id="foot2">[2] By ‚Äúrecipe chain‚Äù I mean all the parent-child relationships that need to be resolved to run the recipe you specify. For example, most jss recipes have a parent pkg recipe which in turn has a parent download recipe. Thus, the download-pkg-jss recipes for a particular product form a chain. I‚Äôm open to using a better term, but the community has not defined one yet. <a href="#ref2">[Return to main text]</a></p>
<p id="foot3">[3] Technically, this is what the <code>--pkg</code> option does every time. Since URLDownloader has an optional input variable named PKG, it gets assigned as the downloaded item that way. <a href="#ref3">[Return to main text]</a></p>